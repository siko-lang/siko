module Main {

import Libc.Arg
import Fs.File
import Fs.Directory
import Fs.Path
import Sys.Command
import Sync.Atomic
import Sync.Thread
import Terminal
import Time

struct Statistics {
    total: AtomicU32,
    passed: AtomicU32,
    failed: AtomicU32,
    skipped: AtomicU32

    fn new() -> Statistics {
        Statistics(
            total: AtomicU32.new(0.toU32()),
            passed: AtomicU32.new(0.toU32()),
            failed: AtomicU32.new(0.toU32()),
            skipped: AtomicU32.new(0.toU32()),
        )
    }

    fn success(&self) {
        self.total.fetchAdd(1.toU32());
        self.passed.fetchAdd(1.toU32());
    }

    fn failure(&self) {
        self.total.fetchAdd(1.toU32());
        self.failed.fetchAdd(1.toU32());
    }

    fn skip(&self) {
        self.total.fetchAdd(1.toU32());
        self.skipped.fetchAdd(1.toU32());
    }

    fn dump(&self) {
        let total = self.total.load();
        let passed = self.passed.load();
        let failed = self.failed.load();
        let skipped = self.skipped.load();
        println("Total: ${total}, Passed: ${passed}, Failed: ${failed} (Skipped: ${skipped})");
    }
}

struct Config {
    filters: Vec[String]
}

@derive(Clone, Copy, Eq, PartialEq)
enum TestType {
    Success,
    Error

    fn validateResult(&self, success: Bool) -> Bool {
        match self {
            Success -> success
            Error -> !success
        }
    }
}

@derive(Clone)
struct Test {
    path: String
    ty: TestType

    fn matchFilters(&self, cfg: &Config) -> Bool {
        if cfg.filters.empty() {
            return True;
        }
        for filter in cfg.filters.iter() {
            if self.path.contains(filter) {
                return True;
            }
        }
        False
    }

    fn compile(&self, binaryOutputPath: &String) -> (Bool, String) {
        let mut command = Command.new("./siko")
            .arg("build")
            .addEnv("SIKO_STD_PATH", "./std")
            .arg(&self.path)
            .arg("-o")
            .arg(&binaryOutputPath)
            .arg("--keep-c-source");
        command.run();
        (command.success(), command.capturedStdout().clone())
    }

    fn runBinary(&self, binaryPath: &String) -> (Bool, String) {
        let mut command = Command.new(binaryPath);
        command.run();
        (command.success(), command.capturedStdout().clone())
    }

    fn getExpectedOutput(&self, stats: &Statistics) -> Result[String, ()] {
        let expectedOutputPath = Fs.Path.join(self.path, "output.txt");
        let expectedOutput = match readFile(expectedOutputPath) {
            Ok(content) -> content,
            Err(_) -> {
                println("Failed to read expected output from ${expectedOutputPath}");
                stats.failure();
                return Err(());
            }
        };
        Ok(expectedOutput)
    }

    fn printFailure(&self, stdLock: &Mutex) {
        stdLock.lock();
        println("- ${self.path} - ${red("failed")}");
        stdLock.unlock();
    }

    fn printSuccess(&self, duration: &Duration, stdLock: &Mutex) {
        stdLock.lock();
        println("- ${self.path} - ${green("success")} (${duration.toMillis()} ms)");
        stdLock.unlock();
    }

    fn printSkipped(&self, stdLock: &Mutex) {
        stdLock.lock();
        println("- ${self.path} - ${yellow("skipped")}");
        stdLock.unlock();
    }

    fn validateOutput(&self, actualOutput: &String, stats: &Statistics, duration: &Duration, stdLock: &Mutex) -> Result[(), ()] {
        let expectedOutput = try self.getExpectedOutput(stats);
        if actualOutput == expectedOutput {
            self.printSuccess(duration, stdLock);
            stats.success();
            Ok(())
        } else {
            self.printFailure(stdLock);
            println("Expected output:");
            println("-----");
            println("${expectedOutput}");
            println("-----");
            println("Actual output:");
            println("-----");
            println("${actualOutput}");
            println("-----");
            stats.failure();
            Err(())
        }
    }

    fn run(&self, stats: &Statistics, stdLock: &Mutex) -> Result[(), ()] {
        let skipPath = Fs.Path.join(self.path, "SKIP");
        if readFile(skipPath).isOk() {
            self.printSkipped(stdLock);
            stats.skip();
            return Ok(());
        }
        let binaryOutputPath = Fs.Path.join(self.path, "main.bin");

        let start = Instant.now();
        let (mut success, mut output) = self.compile(&binaryOutputPath);
        if self.ty == TestType.Success {
            let (s, o) = self.runBinary(&binaryOutputPath);
            success = s;
            output = o;
        }
        let duration = start.elapsed();
        if self.ty.validateResult(success) {
            self.validateOutput(&output, stats, &duration, stdLock);
        } else {
            self.printFailure(stdLock);
            stats.failure();
        }
        Ok(())
    }
}

fn collectTests(basePath: &String, ty: TestType) -> Vec[Test] {
    //println("Collecting tests in ${basePath}");
    let mut result = Vec.new();
    let dirIter = listDir(basePath).expect("Failed to list directory");
    for entry in dirIter {
        let entry = entry.expect("Failed to read directory entry");
        if entry.name() == "." or entry.name() == ".." {
            continue;
        }
        let entryPath = Fs.Path.join(basePath, entry.name());
        if entry.isDirectory() {
            let subPaths = collectTests(&entryPath, ty);
            for subPath in subPaths {
                result.push(subPath);
            }
        } else if entry.name().endsWith(".sk") {
            let test = Test(dirname(entryPath), ty);
            result.push(test);
        }
    }
    return result;
}

struct Executor {
    stats: &Statistics,
    tests: Vec[Test],
    current: AtomicU32,
    stdLock: &Mutex,
    cfg: &Config

    fn new(stats: &Statistics, tests: Vec[Test], stdLock: &Mutex, cfg: &Config) -> Executor {
        Executor(stats: stats, tests: tests, current: AtomicU32.new(0.toU32()), stdLock: stdLock, cfg: cfg)
    }

    fn getNext(&self) -> Option[Test] {
        let index = self.current.fetchAdd(1.toU32()).toInt();
        if index < self.tests.len() {
             Some(self.tests.get(index).clone())
        } else {
            None
        }
    }

    fn run(&self) {
        loop {
            match self.getNext() {
                Some(test) -> {
                    if !test.matchFilters(self.cfg) {
                        continue;
                    }
                    test.run(self.stats, self.stdLock);
                }
                None -> break,
            }
        }
    }
}

fn runParallel(tests: Vec[Test], stats: &Statistics, stdLock: &Mutex, cfg: &Config) {
    let numThreads = 4;
    let executor = Executor.new(stats, tests, stdLock, cfg);
    let mut threads = Vec.new();
    for _ in 0 .. numThreads {
        let exec = &executor;
        let thread = Sync.Thread.spawn(|| {
            exec.run();
        });
        threads.push(thread);
    }
    for thread in threads {
        thread.join();
    }
}

fn runSequential(tests: Vec[Test], stats: &Statistics, stdLock: &Mutex, cfg: &Config) {
    for test in tests {
        if !test.matchFilters(cfg) {
            continue;
        }
        test.run(stats, stdLock);
    }
}

fn main() {
    let mut stdLock = Mutex.new();
    let mut args = getArgs();
    args.remove(0); // remove program name
    let mut cfg = Config(filters: Vec.new());
    for arg in args {
        cfg.filters.push(arg);
    }
    let mut parallelMode = True;
    let stats = Statistics.new();
    let successTests = collectTests("./test/success", Success);
    let errorTests = collectTests("./test/errors", Error);
    if !successTests.empty() {
        println("Success tests:");
        runParallel(successTests, stats, &stdLock, cfg);
    }
    if !errorTests.empty() {
        println("Error tests:");
        runParallel(errorTests, stats, &stdLock, cfg);
    }
    stats.dump();
    if stats.failed.load() > 0.toU32() {
        setExitCode(1.toI32());
    }
}

}
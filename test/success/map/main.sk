module Main {

import NativePtr

pub enum InsertResult {
    Inserted(*Node),
    Duplicate(*Node),
}

instance Show[InsertResult] {
    fn show(&self) -> String {
        match self {
            Inserted(node) -> "Inserted(${node.value})",
            Duplicate(node) -> "Duplicate: ${node.value}",
        }
    }
}

pub struct Node {
    pub value: Int,
    pub height: Int,
    pub left: *Node,
    pub right: *Node,

    fn new(value: Int) -> *Node {
        println("Allocating node for ${value}");
        let node = Node(value, 1, null(), null());
        let p = allocate();
        *p = node;
        p
    }
}

pub struct AvlTree {
    pub root: *Node,

    pub fn new() -> AvlTree {
        AvlTree(null())
    }

    pub fn insert(mut self, value: Int) -> (Self, InsertResult) {
        let (res, new_root) = Main.insert(self.root, value);
        self.root = new_root;
        println("new root is ${get_value(self.root)}");
        (self, res)
    }

    pub fn delete(mut self, value: Int) -> Self {
        self.root = Main.delete(self.root, value);
        self
    }

    pub fn search(&self, value: Int) -> *Node {
        Main.search(self.root, value)
    }

    fn drop(mut self) -> Self {
        println("Dropping AVL Tree");
        free_nodes(self.root);
        self.root = null();
        self
    }
}

fn get_value(node: *Node) -> Int {
    if node.isNull() {
        -1
    } else {
        node.value
    }
}

fn height(n: *Node) -> Int {
    if n.isNull() {
        0
    } else {
        n.height
    }
}

fn update_height(mut n: *Node) {
    if !n.isNull() {
        println("Updating height for node with value: ${get_value(n)}");
        n.height = 1 + max(height(n.left), height(n.right));
    }
}

fn balance_factor(n: *Node) -> Int {
    if n.isNull() {
        0
    } else {
        height(n.left) - height(n.right)
    }
}

fn min_value_node(mut current: *Node) -> *Node {
    if current.isNull() {
        return current;
    }
    while !current.left.isNull() {
        current = current.left;
    }
    current
}

// ======================== Rotations ========================

fn right_rotate(mut z: *Node) -> *Node {
    println("Right rotating around ${get_value(z)}");
    let mut y = z.left;
    let t3 = y.right;

    y.right = z;
    z.left = t3;

    update_height(z);
    update_height(y);

    y
}

fn left_rotate(mut z: *Node) -> *Node {
    println("Left rotating around ${get_value(z)}");
    let mut y = z.right;
    let t2 = y.left;

    println("${get_value(y)}.left = ${get_value(z)}");

    y.left = z;

    println("${get_value(y)}.right = ${get_value(t2)}");

    z.right = t2;

    println("z = ${get_value(z)}");
    println("y = ${get_value(y)}");

    println("y.left = ${get_value(y.left)}");
    println("y.right = ${get_value(y.right)}");

    println("t2 = ${get_value(t2)}");

    update_height(z);
    update_height(y);

    y
}

// ======================== Core ops ========================

fn insert(mut root: *Node, value: Int) -> (InsertResult, *Node) {
    if root.isNull() {
        let n = Node.new(value);
        return (Inserted(n), n);
    }

    if value < root.value {
        println("Inserting ${value} to the left of ${root.value}");
        let (res, new_left) = Main.insert(root.left, value);
        root.left = new_left;
        match res {
            Inserted(_) -> {
                update_height(root);
                let bf = balance_factor(root);
                // Left-Left
                if bf > 1 and value < (root.left).value {
                    let r = right_rotate(root);
                    return (Inserted(r), r);
                }
                // Right-Right
                if bf < -1 and value > (root.right).value {
                    let r = left_rotate(root);
                    return (Inserted(r), r);
                }
                // Left-Right
                if bf > 1 and value > (root.left).value {
                    root.left = left_rotate(root.left);
                    let r = right_rotate(root);
                    return (Inserted(r), r);
                }
                // Right-Left
                if bf < -1 and value < (root.right).value {
                    root.right = right_rotate(root.right);
                    let r = left_rotate(root);
                    return (Inserted(r), r);
                }
                (Inserted(root), root)
            }
            Duplicate(node) -> (Duplicate(node), root),
        }
    } else if value > root.value {
        println("Inserting ${value} to the right of ${root.value}");
        let (res, new_right) = Main.insert(root.right, value);
        root.right = new_right;
        match res {
            Inserted(_) -> {
                update_height(root);
                let bf = balance_factor(root);
                // Left-Left
                if bf > 1 and value < (root.left).value {
                    let r = right_rotate(root);
                    return (Inserted(r), r);
                }
                // Right-Right
                if bf < -1 and value > (root.right).value {
                    let r = left_rotate(root);
                    return (Inserted(r), r);
                }
                // Left-Right
                if bf > 1 and value > (root.left).value {
                    root.left = left_rotate(root.left);
                    let r = right_rotate(root);
                    return (Inserted(r), r);
                }
                // Right-Left
                if bf < -1 and value < (root.right).value {
                    root.right = right_rotate(root.right);
                    let r = left_rotate(root);
                    return (Inserted(r), r);
                }
                (Inserted(root), root)
            }
            Duplicate(node) -> (Duplicate(node), root),
        }
    } else {
        // Duplicate found â€” no insert
        return (Duplicate(root), root);
    }
}

fn dump_tree(root: *Node, level: Int) {
    loop index = 0 {
        if index >= level {
            break;
        }
        print("  ");
        index + 1
    }
    if root.isNull() {
        println("(null)");
        return;
    }
    println("Node value: ${root.value}");
    print("Left: ");
    dump_tree(root.left, level + 1);
    print("Right:");
    dump_tree(root.right, level + 1);
}

fn delete(mut root: *Node, value: Int) -> *Node {
    if root.isNull() {
        return root;
    }

    if value < root.value {
        root.left = Main.delete(root.left, value);
    } else if value > root.value {
        root.right = Main.delete(root.right, value);
    } else {
        let left = root.left;
        let right = root.right;

        if left.isNull() or right.isNull() {
            let child = if !left.isNull() { left } else { right };
            free_node(root);
            return child;
        } else {
            let succ = min_value_node(right);
            root.value = succ.value;
            root.right = Main.delete(right, succ.value);
        }
    }

    if root.isNull() {
        return root;
    }

    update_height(root);
    let bf = balance_factor(root);

    if bf > 1 and balance_factor(root.left) >= 0 {
        return right_rotate(root);
    }
    if bf > 1 and balance_factor(root.left) < 0 {
        root.left = left_rotate(root.left);
        return right_rotate(root);
    }
    if bf < -1 and balance_factor(root.right) <= 0 {
        return left_rotate(root);
    }
    if bf < -1 and balance_factor(root.right) > 0 {
        root.right = right_rotate(root.right);
        return left_rotate(root);
    }

    root
}

fn search(mut root: *Node, value: Int) -> *Node {
    while !root.isNull() {
        if value == root.value {
            return root;
        } else if value < root.value {
            root = root.left;
        } else {
            root = root.right;
        }
    }
    null()
}

// ======================== Cleanup ========================

fn free_nodes(root: *Node) {
    if root.isNull() {
        return;
    }
    let left = root.left;
    let right = root.right;
    free_nodes(left);
    free_nodes(right);
    free_node(root);
}

fn free_node(node: *Node) {
    if node.isNull() {
        return;
    }
    println("Freeing node with value: ${node.value}");
    deallocate(node);
}

// ======================== Traversal ========================

fn inorder(root: *Node) {
    if root.isNull() {
        return;
    }
    inorder(root.left);
    print("${root.value} ");
    inorder(root.right);
}

// ======================== Main Demo ========================

fn main() {
    println("AVL Tree Demo");
    let mut tree = AvlTree.new();

    println("Inserting values:");
    for v in [10, 20, 30, 40, 50, 25, 25] {
        match tree.insert(v) {
            Inserted(_) -> {
                dump_tree(tree.root, 0);
                println("root is ${get_value(tree.root)}");
                println("Inserted ${v}");
            }
            Duplicate(_) -> println("Duplicate ${v} rejected"),
        }
    }

    println("Inorder after inserts:");
    inorder(tree.root);
    println("");

    let found = tree.search(25);
    let res = if found.isNull() { "Not found" } else { "Found" };
    println("Search 25 -> ${res}");

    dump_tree(tree.root, 0);

    tree.delete(40);
    println("Inorder after deleting 40:");
    inorder(tree.root);
    println("");
}

}
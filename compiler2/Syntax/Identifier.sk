module Siko.Syntax.Identifier {

import Siko.Interner as I
import Siko.Location
import Siko.Util

@derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)
struct Fragment {
    pub name: I.String,
    pub location: Location,
}

instance Show[Fragment] {
    fn show(&self) -> String {
        self.name.show()
    }
}

@derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)
pub struct Identifier {
    fragments: Vec[Fragment],
    name: I.String,

    pub fn merge(mut self, other: Identifier) -> Self {
        for fragment in other.fragments {
            self.fragments.push(fragment);
        }
        self.updateName();
        self
    }

    pub fn dot(mut self, location: Location) -> Self {
        self.fragments.push(Fragment(name: I.String.new("."), location));
        self.updateName();
        self
    }

    pub fn new(s: I.String, location: Location) -> Identifier {
        Identifier(fragments: [Fragment(name: s.clone(), location)], name: s)
    }

    pub fn fromString(s: String, location: Location) -> Identifier {
        let name = I.String.new(s);
        Identifier(fragments: [Fragment(name.clone(), location)], name: name)
    }

    pub fn name(&self) -> I.String {
        self.name.clone()
    }

    fn updateName(mut self) -> Self {
        let name = formatList(self.fragments, sep: "");
        self.name = I.String.new(name);
        self
    }

    pub fn location(&self) -> Location {
        if self.fragments.empty() {
            Location.empty()
        } else {
            let mut l = self.fragments[0].location.clone();
            for fragment in self.fragments.iter().skip(1) {
                l = l.merge(fragment.location.clone());
            }
            l
        }
    }

    pub fn split(&self) -> Option[(Identifier, Identifier)] {
        if self.fragments.len() < 3 {
            None
        } else {
            let first = self.fragments.subVec(0, self.fragments.len() - 2);
            let second = self.fragments.subVec(self.fragments.len() - 1, self.fragments.len());
            Some((
                Identifier(
                    fragments: first,
                    name: I.String.new(formatList(first, sep: "")),
                ),
                Identifier(
                    fragments: second,
                    name: I.String.new(formatList(second, sep: "")),
                ),
            ))
        }
    }
}

instance Show[Identifier] {
    fn show(&self) -> String {
        self.name().resolve().clone()
    }
}

}

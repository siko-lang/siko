module Siko.Syntax.Identifier {

import Siko.Interner as I
import Siko.Location

@derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)
struct Fragment {
    pub name: I.String,
    pub location: Location,
}

@derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)
pub struct Identifier {
    fragments: Vec[Fragment],

    pub fn merge(mut self, other: Identifier) -> Self {
        for fragment in other.fragments {
            self.fragments.push(fragment);
        }
        self
    }

    pub fn dot(mut self, location: Location) -> Self {
        self.fragments.push(Fragment(name: I.String.new("."), location));
        self
    }

    pub fn new(s: I.String, location: Location) -> Identifier {
        Identifier(fragments: [Fragment(name: s, location)])
    }

    pub fn name(&self) -> String {
        let parts: Vec[String] = self.fragments
            .iter()
            .map(|f| f.name.clone())
            .collect();
        parts.join("".toString())
    }

    pub fn location(&self) -> Location {
        if self.fragments.empty() {
            Location.empty()
        } else {
            let mut l = self.fragments[0].location.clone();
            for fragment in self.fragments.iter().skip(1) {
                l = l.merge(fragment.location.clone());
            }
            l
        }
    }

    pub fn split(&self) -> Option[(Identifier, Identifier)] {
        if self.fragments.len() < 3 {
            None
        } else {
            let first = self.fragments.subVec(0, self.fragments.len() - 2);
            let second = self.fragments.subVec(self.fragments.len() - 1, self.fragments.len());
            Some((
                Identifier(
                    fragments: first,
                ),
                Identifier(
                    fragments: second,
                ),
            ))
        }
    }
}

pub instance IdentifierShow Show[Identifier] {
    fn show(&self) -> String {
        self.name()
    }
}

}

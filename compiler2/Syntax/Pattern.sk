module Siko.Syntax.Pattern {

import Siko.Syntax.Identifier
import Siko.Syntax.Expr
import Siko.Location
import Siko.Util

@derive(Clone, PartialEq, Eq)
pub struct Pattern {
    pub pattern: SimplePattern,
    pub location: Location,

    pub fn isGuarded(&self) -> Bool {
        self.pattern.isGuarded()
    }
}

@derive(Clone, PartialEq, Eq)
pub enum SimplePattern {
    Named(Identifier, Vec[Pattern]),
    Bind(Identifier, Bool), // mutable
    Tuple(Vec[Pattern]),
    StringLiteral(String),
    IntegerLiteral(String),
    Wildcard,
    Guarded(Pattern, Expr),
    OrPattern(Vec[Pattern]),

    pub fn isGuarded(&self) -> Bool {
        match self {
            Guarded(_, _) -> True,
            _ -> False,
        }
    }
}

instance Show[Pattern] {
    fn show(&self) -> String {
        "${self.pattern}"
    }
}

instance Show[SimplePattern] {
    fn show(&self) -> String {
        match self {
            Named(identifier, patterns) -> {
                if patterns.empty() {
                    "${identifier}"
                } else {
                    let patterns = formatList(patterns);
                    "${identifier}(${patterns})"
                }
            }
            Bind(identifier, mutable) -> {
                if mutable {
                    "mut ${identifier}"
                } else {
                    "${identifier}"
                }
            }
            Tuple(patterns) -> {
                formatList(patterns, sep: ", ", begin: "(", end: ")")
            }
            StringLiteral(value) -> "\"${value}\"",
            IntegerLiteral(value) -> "${value}",
            Wildcard -> "_".toString(),
            Guarded(pattern, expr) -> "${pattern} if { ${expr} }",
            OrPattern(patterns) -> {
                formatList(patterns, sep: " | ")
            }
        }
    }
}

}
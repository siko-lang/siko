module Siko.Syntax.Type {

import Siko.Syntax.Identifier

@derive(Debug, Clone, PartialEq, Eq)
pub enum Type {
    Named(Identifier, Vec[Type]),
    Tuple(Vec[Type]),
    Function(Vec[Type], Type),
    FunctionPtr(Vec[Type], Type),
    Reference(Type),
    Ptr(Type),
    SelfType,
    Never,
    NumericConstant(String),
    Void,
    VoidPtr,
    Coroutine(Type, Type), //  Yield type, Return type
}

pub instance Show[Type] {
    fn show(&self) -> String {
        match self {
            Named(id, args) -> {
                if args.empty() {
                    "${id}"
                } else {
                    "${id}${args}"
                }
            }
            Tuple(elements) -> {
                let elems: Vec[String] = elements
                    .iter()
                    .map(|el| el.show())
                    .collect();
                let elems = elems.join(", ".toString());
                "(${elems})"
            }
            Function(params, ret) -> {
                let params: Vec[String] = params
                    .iter()
                    .map(|param| param.show())
                    .collect();
                let params = params.join(", ".toString());
                "fn(${params}) -> ${ret}"
            }
            FunctionPtr(params, ret) -> {
                let params: Vec[String] = params
                    .iter()
                    .map(|param| param.show())
                    .collect();
                let params = params.join(", ".toString());
                "fn*(${params}) -> ${ret}"
            }
            Reference(inner) -> "&${inner}"
            Ptr(inner) -> "*${inner}"
            SelfType -> "Self".toString()
            Never -> "!".toString()
            NumericConstant(value) -> "${value}"
            Void -> "void".toString()
            VoidPtr -> "void*".toString()
            Coroutine(yieldTy, retTy) -> "co(${yieldTy}) -> ${retTy}"
        }
    }
}

@derive(Debug, Clone, PartialEq, Eq)
pub struct TypeParameterDeclaration {
    pub params: Vec[Identifier],
    pub constraints: Vec[Constraint],
}

pub instance Show[TypeParameterDeclaration] {
    fn show(&self) -> String {
        let params: Vec[String] = self
            .params
            .iter()
            .map(|param| param.show())
            .collect();
        if self.constraints.empty() {
            "[${params.join(", ".toString())}]"
        } else {
            let constraints: Vec[String] = self
                .constraints
                .iter()
                .map(|constraint| constraint.show())
                .collect();
            "[${params.join(", ".toString())}: ${constraints.join(", ".toString())}]"
        }
    }
}

@derive(Debug, Clone, PartialEq, Eq)
pub enum ConstraintArgument {
    Type(Type),
    AssociatedType(Identifier, Type),
}

@derive(Debug, Clone, PartialEq, Eq)
pub struct Constraint {
    pub name: Identifier,
    pub args: Vec[ConstraintArgument],
}

pub instance Show[Constraint] {
    fn show(&self) -> String {
        "${self.name}${self.args}"
    }
}

pub instance Show[ConstraintArgument] {
    fn show(&self) -> String {
        match self {
            ConstraintArgument.Type(ty) -> {
                "${ty}"
            }
            ConstraintArgument.AssociatedType(id, ty) -> {
                "${id} = ${ty}"
            }
        }
    }
}

}
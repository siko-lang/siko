module Siko.Syntax.Type {

import Siko.Interner as I
import Siko.Syntax.Identifier
import Siko.Util

@derive(Debug, Clone, PartialEq, Eq)
pub enum Type {
    Named(Identifier, Vec[Type]),
    Tuple(Vec[Type]),
    Function(Vec[Type], Type),
    FunctionPtr(Vec[Type], Type),
    Reference(Type),
    Ptr(Type),
    SelfType,
    Never,
    NumericConstant(I.String),
    Void,
    VoidPtr,
    Coroutine(Type, Type), //  Yield type, Return type
}

pub instance Show[Type] {
    fn show(&self) -> String {
        match self {
            Named(id, args) -> {
                if args.empty() {
                    "${id}"
                } else {
                    "${id}${args}"
                }
            }
            Tuple(elements) -> {
                formatList(elements, sep: ", ", begin: "(", end: ")")
            }
            Function(params, ret) -> {
                let params = formatList(params);
                "fn(${params}) -> ${ret}"
            }
            FunctionPtr(params, ret) -> {
                let params = formatList(params);
                "fn*(${params}) -> ${ret}"
            }
            Reference(inner) -> "&${inner}"
            Ptr(inner) -> "*${inner}"
            SelfType -> "Self".toString()
            Never -> "!".toString()
            NumericConstant(value) -> "${value}"
            Void -> "void".toString()
            VoidPtr -> "void*".toString()
            Coroutine(yieldTy, retTy) -> "co(${yieldTy}) -> ${retTy}"
        }
    }
}

@derive(Debug, Clone, PartialEq, Eq)
pub struct TypeParameterDeclaration {
    pub params: Vec[Identifier],
    pub constraints: Vec[Constraint],
}

pub instance Show[TypeParameterDeclaration] {
    fn show(&self) -> String {
        let params = formatList(self.params);
        if self.constraints.empty() {
            "[${params}]"
        } else {
            let constraints = formatList(self.constraints);
            "[${params}: ${constraints}]"
        }
    }
}

@derive(Debug, Clone, PartialEq, Eq)
pub enum ConstraintArgument {
    Type(Type),
    AssociatedType(Identifier, Type),
}

@derive(Debug, Clone, PartialEq, Eq)
pub struct Constraint {
    pub name: Identifier,
    pub args: Vec[ConstraintArgument],
}

pub instance Show[Constraint] {
    fn show(&self) -> String {
        "${self.name}${self.args}"
    }
}

pub instance Show[ConstraintArgument] {
    fn show(&self) -> String {
        match self {
            ConstraintArgument.Type(ty) -> {
                "${ty}"
            }
            ConstraintArgument.AssociatedType(id, ty) -> {
                "${id} = ${ty}"
            }
        }
    }
}

}
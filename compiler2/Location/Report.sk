module Siko.Location.Report {

import Siko.Location
import Terminal

pub struct Entry {
    msg: Option[String],
    location: Location,

    pub fn new(msg: Option[String], location: Location) -> Entry {
        Entry(
            msg: msg,
            location: location,
        )
    }
}

pub struct Report {
    slogan: String,
    entries: Vec[Entry],

    pub fn new(slogan: String, location: Option[Location]) -> Report {
        let mut entries = Vec.new();
        match location {
            Some(loc) -> {
                entries.push(Entry.new(None, loc));
            }
            None -> {
            }
        }
        build(slogan, entries)
    }

    pub fn build(slogan: String, entries: Vec[Entry]) -> Report {
        Report(
            slogan: slogan,
            entries: entries,
        )
    }

    pub fn print(&self) {
        println("${red("ERROR")}: ${self.slogan}");
        for entry in self.entries {
            match entry.msg {
                Some(msg) -> {
                    println("   ${blue(msg)}");
                }
                None -> {
                }
            }
            let filename = entry.location.fileId.getFileName();
            let startLoc = entry.location.span.start.line + 1.toU32();
            let startOffset = entry.location.span.start.offset + 1.toU32();
            println("${red(" --->")} ${filename}:${startLoc}:${startOffset}");
            let lines = entry.location.fileId.getLines();
            let startLine = entry.location.span.start.line;
            let endLine = entry.location.span.end.line;
            let mut separatorPrinted = False;
            for (lineNumber, line) in lines.iter().enumerate() {
                let lineNumber = lineNumber.toU32();
                let distance = min((lineNumber - startLine), (endLine - lineNumber));
                if lineNumber >= startLine and lineNumber <= endLine {
                    if distance < 3.toU32() {
                        let highlighted_line = if lineNumber == startLine and lineNumber == endLine {
                            let start = entry.location.span.start.offset;
                            let end = entry.location.span.end.offset;
                            let mut modifiedLine = String.new();
                            modifiedLine.push(line.subString(0.toU64(), start.toU64()));
                            modifiedLine.push(yellow(line.subString(start.toU64(), end.toU64())));
                            modifiedLine.push(line.subString(end.toU64(), line.len().toU64()));
                            modifiedLine
                        } else if lineNumber == startLine {
                            let start = entry.location.span.start.offset;
                            let mut modifiedLine = String.new();
                            modifiedLine.push(line.subString(0.toU64(), start.toU64()));
                            modifiedLine.push(yellow(line.subString(start.toU64(), line.len().toU64())));
                            modifiedLine
                        } else if lineNumber == endLine {
                            let end = entry.location.span.end.offset;
                            let mut modifiedLine = String.new();
                            modifiedLine.push(yellow(line.subString(0.toU64(), end.toU64())));
                            modifiedLine.push(line.subString(end.toU64(), line.len().toU64()));
                            modifiedLine
                        } else {
                            yellow(line)
                        };
                        let lineNumberStr = "${lineNumber + 1.toU32()}";
                        println(" ${red("|")} ${blue(lineNumberStr)} ${highlighted_line}");
                    } else {
                        if !separatorPrinted {
                            separatorPrinted = True;
                            println(" ...");
                        }
                    }
                }
            }
        }
    }
}

}
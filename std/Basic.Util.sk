module Std.Basic.Util {

import NativePtr
import Libc.Unistd as Unistd
import Libc.StdLib as StdLib

@safe
pub fn printStr(v: &String) {
    Unistd.write(1.toI32(), v.slice().asPtr(), v.slice().len());
}

@safe
pub fn printlnStr(v: &String) {
    Unistd.write(1.toI32(), v.slice().asPtr(), v.slice().len());
    Unistd.write(1.toI32(), "\\n".slice().asPtr(), 1.toU64());
    Unistd.fsync(1.toI32());
}

@safe
pub fn assert(v: Bool) {
    if v {
    } else {
        println("Assertion failed");
        StdLib.abort();
    }
}

pub fn print(msg: &String) {
    printStr(msg);
}

pub fn println(msg: &String) {
    printlnStr(msg);
}

@safe
pub fn panic(msg: String) -> ! {
    printStr("PANIC: ");
    printStr(msg);
    printStr("\\n");
    StdLib.abort();
}

@safe
pub fn readChar() -> Result[U8, ()] {
    let buf: U8 = 0.toU8();
    let bytesRead = Unistd.read(0.toI32(), NativePtr.toPtr(&buf), 1.toU64());
    if bytesRead <= 0 {
        panic("Failed to read character");
    }
    Ok(buf)
}

@safe
pub fn readLine() -> String {
    let mut buf = Vec.new(128);
    let mut bytesRead = 0;
    loop {
        let result = readChar();
        match result {
            Ok(c) -> {
                if c == 10.toU8() { // 10 is \n : TODO: make char literals work!
                   break;
                }
                buf.push(c);
            }
            Err(()) -> {
                panic("Failed to read character");
            }
        }
        bytesRead += 1;
    }
    return String.fromU8(buf.slice());

}

}
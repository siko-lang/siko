module Std.Basic.Util {

import NativePtr
import Libc

pub fn printStr(v: &String) {
    let fmt = "%.*s".slice().asPtr();
    Libc.printf(NativePtr.transmute(fmt), NativePtr.transmute(v.len()), v.slice().asPtr());
}

pub fn printlnStr(v: &String) {
    let fmt = "%.*s\\n".slice().asPtr();
    Libc.printf(NativePtr.transmute(fmt), NativePtr.transmute(v.len()), v.slice().asPtr());
}

pub fn assert(v: Bool) {
    if v {
    } else {
        println("Assertion failed");
        Libc.abort();
    }
}

pub fn print(msg: &String) {
    printStr(msg);
}

pub fn println(msg: &String) {
    printlnStr(msg);
}

pub fn panic(msg: String) -> ! {
    printStr("PANIC");
    printStr(msg);
    abort();
}

pub fn readChar() -> Result[U8, ()] {
    let buf: U8 = 0.toU8();
    let bytesRead = Libc.read(0.toI32(), NativePtr.toPtr(&buf), 1.toU64());
    if bytesRead <= 0 {
        panic("Failed to read character");
    }
    Ok(buf)
}

pub fn readLine() -> String {
    let mut buf = Vec.withCapacity(128);
    let mut bytesRead = 0;
    loop {
        let result = readChar();
        match result {
            Ok(c) -> {
                if c == 10.toU8() { // 10 is \n : TODO: make char literals work!
                   break;
                }
                buf.push(c);
            }
            Err(()) -> {
                panic("Failed to read character");
            }
        }
        bytesRead += 1;
    }
    return String.fromU8(buf);

}

}
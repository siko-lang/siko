module Vec {

import NativePtr
import Slice

struct InnerVec[T] {
    items: *T,
    size: U64,
    capacity: U64

    @unsafe
    fn new() -> InnerVec[T] {
        InnerVec(null(), 0.toU64(), 0.toU64())
    }

    @safe
    fn push(mut self, item: T) -> Self {
        if self.size == self.capacity {
            if self.capacity == 0.toU64() {
                self.grow(8.toU64());
            } else {
                self.grow(self.capacity * 2.toU64());
            }
        }
        let ptr = offset(self.items, self.size);
        *ptr = item;
        self.size += 1.toU64();
        self
    }

    @unsafe
    fn get(&self, index: U64) -> &T {
        if self.size <= index {
            panic("OutOfBounds");
        }
        self.getUnchecked(index)
    }

    @unsafe
    fn getUnchecked(&self, index: U64) -> &T {
        let ptr = offset(self.items, index);
        toRef(ptr)
    }

    @unsafe
    pub fn remove(mut self, index: U64) -> Self {
        if index < 0.toU64() or index >= self.size {
            panic("OutOfBounds");
        }
        let ptr = offset(self.items, index);
        {
            let item = *ptr; // drop the item at the index
        }
        // shift the items to the left using memmove
        let nextPtr = offset(self.items, (index + 1.toU64()));
        let destPtr = offset(self.items, index);
        memmove(destPtr, nextPtr, (self.size - index - 1.toU64()));
        self.size -= 1.toU64();
        self
    }

    @unsafe
    fn grow(mut self, capacity: U64) -> Self {
        self.capacity = capacity;
        let newItems: *T = allocateArray(self.capacity);
        if self.size > 0.toU64() {
            memcpy(newItems, self.items, self.size);
        }
        if !self.items.isNull() {
            deallocate(self.items);
        }
        self.items = newItems;
        self
    }
}

pub struct Vec[T] {
    inner: InnerVec[T]

    @safe
    pub fn new() -> Vec[T] {
        Vec(InnerVec.new())
    }

    @safe
    pub fn withCapacity(capacity: Int) -> Vec[T] {
        let mut vec = Vec.new();
        vec.inner.grow(capacity.toU64());
        vec
    }

    pub fn push(mut self, item: T) -> Self {
        self.inner.push(item);
        self
    }

    @safe
    pub fn get(&self, index: Int) -> &T {
        self.inner.get(index.toU64())
    }


    @safe
    pub fn getUnchecked(&self, index: Int) -> &T {
        self.inner.getUnchecked(index.toU64())
    }

    @safe
    pub fn remove(mut self, index: Int) -> Self {
        self.inner.remove(index.toU64());
        self
    }

    pub fn iter(&self) -> VecIteratorRef[T] {
        VecIteratorRef(&self, 0.toU64())
    }

    pub fn intoIter(self) -> VecIterator[T] {
        VecIterator(self.inner, 0.toU64())
    }

    pub fn len(&self) -> Int {
        self.inner.size.toInt()
    }

    pub fn empty(&self) -> Bool {
        self.inner.size == 0.toU64()
    }

    @unsafe
    pub fn slice(&self) -> Slice[T] {
        Slice.new(self.inner.items, self.inner.size)
    }

    @safe
    pub fn swap(self, i: Int, j: Int) -> Self {
        self.slice().swap(i.toU64(), j.toU64());
        self
    }

    @safe
    pub fn reverse(self) -> Self {
        self.slice().reverse();
        self
    }

    @safe
    pub fn sort[T: Ord[T]](mut self) -> Self {
        self.slice().sort();
        self
    }

    @safe
    pub fn sort2[T: Ord[T]](mut self) -> Self {
        self.slice().sort2();
        self
    }

    @safe
    pub fn contains[T: PartialEq[T]](&self, item: &T) -> Bool {
        self.slice().contains(item)
    }

    @unsafe
    pub fn asPtr(&self) -> *T {
        self.inner.items
    }
}

struct VecIterator[T] {
    inner: InnerVec[T],
    index: U64
}

instance[T] Drop[VecIterator[T]] {
    @unsafe
    fn drop(mut self) -> Self {
        if self.inner.capacity == 0.toU64() {
            return self
        }
        loop {
            if self.index >= self.inner.size {
                break;
            }
            let ptr = offset(self.inner.items, self.index);
            self.index = self.index + 1.toU64();
            let item = *ptr;
        }
        deallocate(self.inner.items);
        self.inner.items = null();
        self
    }
}

pub instance[T] IteratorVecIterator Iterator[VecIterator[T]] {
    type Item = T

    @safe
    fn next(mut self) -> (Self, Option[T]) {
        if self.index >= self.inner.size {
            return (self, None)
        }
        let ptr = offset(self.inner.items, self.index);
        self.index = self.index + 1.toU64();
        let item = *ptr;
        (self, Some(item))
    }
}

pub instance[T] IntoIteratorVec IntoIterator[Vec[T]] {
    type Item = T
    type Iter = VecIterator[T]

    fn intoIterator(self) -> VecIterator[T] {
        self.intoIter()
    }
}

struct VecIteratorRef[T] {
    vec: &Vec[T]
    index: U64
}

pub instance[T] IteratorVecIteratorRef Iterator[VecIteratorRef[T]] {
    type Item = &T

    @safe
    fn next(mut self) -> (Self, Option[&T]) {
        if self.index >= self.vec.inner.size {
            return (self, None)
        }
        let item = self.vec.inner.getUnchecked(self.index);
        self.index = self.index + 1.toU64();
        (self, Some(item))
    }
}

instance[T] Drop[Vec[T]] {
    @unsafe
    fn drop(mut self) -> Self {
        {
            let iter = VecIterator(self.inner, 0.toU64());
            self.inner = InnerVec.new();
        }
        self
    }
}

pub instance[T: Show[T]] ShowVec Show[Vec[T]] {
    fn show(&self) -> String {
        let mut result = String.new();
        result.push("[");
        let mut first = True;
        for item in self.iter() {
            if !first {
                result.push(", ");
            }
            first = False;
            result.push(item.show());
        }
        result.push("]");
        result
    }
}

pub instance[T: PartialEq[T]] PartialEqVec PartialEq[Vec[T]] {
    fn eq(&self, other: &Vec[T]) -> Bool {
        if self.len() != other.len() {
            return False;
        }
        loop i = 0 {
            if i >= self.len() {
                break;
            }
            let a = self.getUnchecked(i);
            let b = other.getUnchecked(i);
            if a != b {
                return False;
            }
            i + 1
        }
        True
    }
}

pub instance[T: Clone[T]] VecClone Clone[Vec[T]] {
    @safe
    fn clone(&self) -> Vec[T] {
        let mut newVec: Vec[T] = Vec.new();
        newVec.inner.grow(self.inner.capacity);
        for item in self.iter() {
            newVec.push(item.clone());
        }
        newVec
    }
}

@test
fn simpleVecExample()  {
    let mut vec = Vec.new();
    vec.push(1);
    assert(vec.len() == 1);
}

}
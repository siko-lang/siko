module Std.Cmp {

pub protocol PartialEq[T] {
    fn eq(&self, other: &T) -> Bool

    fn ne(&self, other: &T) -> Bool {
        !self.eq(other)
    }
}

pub protocol[T: PartialEq[T]] Eq[T]

pub protocol[T: PartialEq[T]] PartialOrd[T] {
    fn partialCmp(&self, other: &T) -> Option[Ordering]

    fn lessThan(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Less) -> True,
            _ -> False
        }
    }

    fn lessOrEqual(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Less) -> True,
            Some(Equal) -> True,
            _ -> False
        }
    }

    fn greaterThan(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Greater) -> True,
            _ -> False
        }
    }

    fn greaterOrEqual(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Greater) -> True,
            Some(Equal) -> True,
            _ -> False
        }
    }
}

pub protocol[T: PartialOrd[T], PartialEq[T], Eq[T]] Ord[T] {
    fn cmp(&self, other: &T) -> Ordering

    fn max(self, other: T) -> T {
        if self >= other { self } else { other }
    }

    fn min(self, other: T) -> T {
        if self <= other { self } else { other }
    }
}

}
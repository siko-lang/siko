module Range {

pub struct Range[T] {
    start: T,
    end: T

    pub fn range[T](start: T, end: T) -> Range[T] {
        Range(start, end)
    }

    pub fn contains[T: Ord[T]](&self, value: T) -> Bool {
        value >= self.start and value < self.end
    }

    pub fn intoIterator[T: Clone[T]](self) -> RangeIterator[T] {
        RangeIterator.new(self)
    }
}

pub struct RangeIterator[T] {
    range: Range[T],
    current: T,

    pub fn new[T: Clone[T]](range: Range[T]) -> RangeIterator[T] {
        RangeIterator(range, range.start.clone())
    }
}

pub instance[T: Clone[T]] IntoIteratorRange IntoIterator[Range[T]] {
    type Item = T
    type Iter = RangeIterator[T]

    fn intoIterator(self) -> RangeIterator[T] {
        RangeIterator.new(self)
    }
}

pub instance[T: Ord[T], Step[T]] IteratorRangeIterator Iterator[RangeIterator[T]] {
    type Item = T

    fn next(mut self) -> (Self, Option[T]) {
        if self.current < self.range.end {
            let nextValue = self.current.step();
            let current = self.current;
            self.current = nextValue;
            (self, Some(current))
        } else {
            (self, None)
        }
    }
}

pub trait Step[T] {
    fn step(&self) -> T
}

pub instance Step[Int] {
    fn step(&self) -> Int {
        self.clone() + 1
    }
}

pub instance Step[U64] {
    fn step(&self) -> U64 {
        self.clone() + 1.toU64()
    }
}

}
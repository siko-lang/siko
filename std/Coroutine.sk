module Coroutine {

pub enum Result[Y, R] {
    Yielded(Y),
    Returned(R),
    Completed,

    pub fn getYielded(self) -> Y {
        match self {
            Yielded(v) -> v,
            _ -> panic("Not a yielded value"),
        }
    }

    pub fn getReturned(self) -> R {
        match self {
            Returned(v) -> v,
            _ -> panic("Not a returned value"),
        }
    }

    pub fn isCompleted(self) -> Bool {
        match self {
            Completed -> True,
            _ -> False,
        }
    }
}

@safe
pub fn resume[Y, R](coro: co(Y) -> R) -> (co(Y) -> R,  Result[Y, R]) {
    return coResume(coro);
}

@safe
pub fn isCompleted[Y, R](coro: &co(Y) -> R) -> Bool {
    return coIsCompleted(coro);
}

fn coResume[Y, R](coro: co(Y) -> R) -> (co(Y) -> R,  Result[Y, R]) = extern

fn coIsCompleted[Y, R](coro: &co(Y) -> R) -> Bool = extern

pub instance[Y, R] CoIterator Iterator[co(Y) -> R] {
    type Item = Y

    fn next(self) -> (Self, Option[Y]) {
        let (coro, res) = resume(self);
        match res {
            Result.Yielded(v) -> (coro, Some(v)),
            Result.Returned(_) -> (coro, None),
            Result.Completed -> (coro, None),
        }
    }
}

}
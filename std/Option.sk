module Option {

@derive(PartialEq, Eq, PartialOrd, Ord, Show)
pub enum Option[T] {
    None,
    Some(T),

    pub fn unwrap(self) -> T {
        match self {
            Some(v) -> v,
            None -> panic("Unwrap called on Option.None")
        }
    }

    pub fn expect(self, msg: String) -> T {
        match self {
            Some(v) -> v,
            None -> panic(msg)
        }
    }

    pub fn isSome(&self) -> Bool {
        match self {
            Some(_) -> True,
            _ -> False,
        }
    }

    pub fn isNone(&self) -> Bool {
        match self {
            None -> True,
            _ -> False,
        }
    }
}

pub instance[T: Clone[T]] OptionClone Clone[Option[T]] {
    fn clone(&self) -> Option[T] {
        match self {
            Some(v) -> Some(v.clone()),
            None -> None,
        }
    }
}

pub instance[T: Copy[T]] CopyOption Copy[Option[T]]

}
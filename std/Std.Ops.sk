module Std.Ops {

pub trait Add[T, U] {
    type Output
    fn add(self, other: U) -> Output
}

pub trait Sub[T] {
    fn sub(self, other: T) -> T
}

pub trait Mul[T] {
    fn mul(self, other: T) -> T
}

pub trait Div[T] {
    fn div(self, other: T) -> T
}

pub trait PartialEq[T] {
    fn eq(&self, other: &T) -> Bool

    fn ne(&self, other: &T) -> Bool {
        !self.eq(other)
    }
}

pub trait[T: PartialEq[T]] Eq[T]

pub trait[T: PartialEq[T]] PartialOrd[T] {
    fn partialCmp(&self, other: &T) -> Option[Ordering]

    fn lessThan(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Less) -> True,
            _ -> False
        }
    }

    fn lessOrEqual(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Less) -> True,
            Some(Equal) -> True,
            _ -> False
        }
    }

    fn greaterThan(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Greater) -> True,
            _ -> False
        }
    }

    fn greaterOrEqual(&self, other: &T) -> Bool {
        match self.partialCmp(other) {
            Some(Greater) -> True,
            Some(Equal) -> True,
            _ -> False
        }
    }
}

pub trait[T: PartialOrd[T], Eq[T]] Ord[T] {
    fn cmp(&self, other: &T) -> Ordering

    fn max(self, other: T) -> T {
        if self >= other { self } else { other }
    }

    fn min(self, other: T) -> T {
        if self <= other { self } else { other }
    }
}

pub trait Not[T] {
    fn not(self) -> T
}

pub trait Neg[T] {
    fn negative(self) -> T
}

pub trait Clone[T] {
    fn clone(&self) -> T
}

pub trait Copy[T]

pub trait Drop[T] {
    fn drop(self) -> Self
}

pub trait ImplicitConvert[T, U] {
    fn implicitConvert(self) -> U
}

pub trait Show[T] {
    fn show(&self) -> String

    fn toString(&self) -> String {
        self.show()
    }
}

}
module Slice {

import NativePtr

pub struct Slice[T] {
    pub items: *T,
    pub size: U64,

    pub fn new(items: *T, size: U64) -> Slice[T] {
        Slice(items, size)
    }

    pub fn len(&self) -> U64 {
        self.size
    }

    pub fn isEmpty(&self) -> Bool {
        self.size == 0.toU64()
    }

    @unsafe
    fn getUnchecked(&self, index: U64) -> &T {
        let ptr = offset(self.items, index);
        toRef(ptr)
    }

    @unsafe
    fn getPtr(&self, index: U64) -> *T {
        offset(self.items, index)
    }

    @unsafe
    fn asPtr(&self) -> *T {
        self.items
    }

    @unsafe
    fn contains[T: PartialEq[T]](&self, item: &T) -> Bool {
        for i in 0.toU64()..self.size {
            if self.getUnchecked(i) == item {
                return True;
            }
        }
        False
    }

    @unsafe
    pub fn swap(self, i: U64, j: U64) -> Self {
        if i == j {
            return self;
        }
        let ptr = self.getPtr(i);
        let ptr2 = self.getPtr(j);
        let item = *ptr;
        let item2 = *ptr2;
        *ptr = item2;
        *ptr2 = item;
        self
    }

    @unsafe
    fn subSlice(&self, from: U64, to: U64) -> Slice[T] {
        if from < 0.toU64() or to > self.size or from > to {
            panic("Invalid slice range ${from}-${to} must be between 0 and ${self.size}");
        }
        let newSize = to - from;
        Slice(self.getPtr(from), newSize)
    }

    @unsafe
    pub fn sort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1.toU64() {
            return self;
        }

        self.quickSort();
        self
    }

    @unsafe
    pub fn sort2[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1.toU64() {
            return self;
        }

        self.quickSort2();
        self
    }

    @unsafe
    fn quickSort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1.toU64() {
            return self;
        }
        let p = self.partition();
        let left = self.subSlice(0.toU64(), p.toU64());
        let right = self.subSlice((p + 1).toU64(), self.len());
        left.quickSort();
        right.quickSort();
        self
    }

    @unsafe
    fn partition[T: Ord[T]](mut self) -> (Self, Int) {
        let lo = 0;
        let hi = self.len().toInt() - 1;
        let pivot: T = *(toPtr(self.getUnchecked(hi.toU64()))); // pick last element as pivot
        let mut i = lo - 1;
        for j in lo..hi {
            if self.getUnchecked(j.toU64()) <= pivot {
                i += 1;
                self.swap(i.toU64(), j.toU64());
            }
        }
        self.swap((i + 1).toU64(), hi.toU64());
        (self, i + 1)
    }

    @unsafe
    fn quickSort2[T: Ord[T]](mut self) -> Self {
        if self.len().toInt() <= 1 {
            return self;
        }

        let (lt, gt) = self.partition3();

        // Recursively sort < pivot
        self.subSlice(0.toU64(), lt.toU64()).quickSort2();

        // Recursively sort > pivot
        self.subSlice((gt + 1).toU64(), self.len()).quickSort2();

        self
    }

    @unsafe
    fn partition3[T: Ord[T]](mut self) -> (Self, Int, Int) {
        let lo = 0;
        let hi = self.len().toInt() - 1;
        let pivot: T = *(toPtr(self.getUnchecked(lo.toU64()))); // pick first element as pivot

        let mut lt = lo;   // end of < pivot region
        let mut gt = hi;   // start of > pivot region
        let mut i  = lo;   // current element

        while i <= gt {
            if self.getUnchecked(i.toU64()) < pivot {
                self.swap(lt.toU64(), i.toU64());
                lt += 1;
                i += 1;
            } else if self.getUnchecked(i.toU64()) > pivot {
                self.swap(i.toU64(), gt.toU64());
                gt -= 1;
                // dont increment i, need to examine swapped element
            } else {
                i += 1; // equal to pivot
            }
        }

        (self, lt, gt) // indices of first == pivot and last == pivot
    }

    @unsafe
    pub fn reverse(mut self) -> Self {
        let mut i = 0.toU64();
        if self.len() < 2.toU64() {
            return self;
        }
        let mut j = self.len() - 1.toU64();
        while i < j {
            self.swap(i, j);
            i += 1.toU64();
            j -= 1.toU64();
        }
        self
    }
}

}
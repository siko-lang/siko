module Slice {

import NativePtr

pub struct Slice[T] {
    pub items: *T,
    pub size: Int,

    pub fn new(items: *T, size: Int) -> Slice[T] {
        Slice(items, size)
    }

    pub fn len(&self) -> Int {
        self.size
    }

    pub fn isEmpty(&self) -> Bool {
        self.size == 0
    }

    fn getUnchecked(&self, index: Int) -> &T {
        let ptr = offset(self.items, index);
        toRef(ptr)
    }

    fn getPtr(&self, index: Int) -> *T {
        offset(self.items, index)
    }

    pub fn swap(self, i: Int, j: Int) -> Self {
        if i == j {
            return self;
        }
        let ptr = self.getPtr(i);
        let ptr2 = self.getPtr(j);
        let item = *ptr;
        let item2 = *ptr2;
        *ptr = item2;
        *ptr2 = item;
        self
    }

    fn subSlice(&self, from: Int, to: Int) -> Slice[T] {
        if from < 0 or to > self.size or from > to {
            panic("Invalid slice range ${from}-${to} must be between 0 and ${self.size}");
        }
        let newSize = to - from;
        Slice(self.getPtr(from), newSize)
    }

    pub fn sort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }

        self.quickSort();
        self
    }

    fn quickSort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }
        let p = self.partition();
        let left = self.subSlice(0, p);
        let right = self.subSlice(p + 1, self.len());
        left.quickSort();
        right.quickSort();
        self
    }

    fn partition[T: Ord[T]](mut self) -> (Self, Int) {
        let lo = 0;
        let hi = self.len() - 1;
        let pivot = self.getUnchecked(hi);
        let mut i = lo - 1;
        for j in lo..hi {
            if self.getUnchecked(j) <= pivot {
                i = i + 1;
                self.swap(i, j);
            }
        }
        self.swap(i + 1, hi);
        (self, i + 1)
    }

    pub fn reverse(mut self) -> Self {
        let mut i = 0;
        let mut j = self.len() - 1;
        while i < j {
            self.swap(i, j);
            i = i + 1;
            j = j - 1;
        }
        self
    }
}

}
module Slice {

import NativePtr

pub struct Slice[T] {
    pub items: *T,
    pub size: Int,

    pub fn new(items: *T, size: Int) -> Slice[T] {
        Slice(items, size)
    }

    pub fn len(&self) -> Int {
        self.size
    }

    pub fn isEmpty(&self) -> Bool {
        self.size == 0
    }

    fn getUnchecked(&self, index: Int) -> &T {
        let ptr = offset(self.items, index);
        toRef(ptr)
    }

    fn getPtr(&self, index: Int) -> *T {
        offset(self.items, index)
    }

    fn asPtr(&self) -> *T {
        self.items
    }

    fn contains[T: PartialEq[T]](&self, item: &T) -> Bool {
        for i in 0..self.size {
            if self.getUnchecked(i) == item {
                return True;
            }
        }
        False
    }

    pub fn swap(self, i: Int, j: Int) -> Self {
        if i == j {
            return self;
        }
        let ptr = self.getPtr(i);
        let ptr2 = self.getPtr(j);
        let item = *ptr;
        let item2 = *ptr2;
        *ptr = item2;
        *ptr2 = item;
        self
    }

    fn subSlice(&self, from: Int, to: Int) -> Slice[T] {
        if from < 0 or to > self.size or from > to {
            panic("Invalid slice range ${from}-${to} must be between 0 and ${self.size}");
        }
        let newSize = to - from;
        Slice(self.getPtr(from), newSize)
    }

    pub fn sort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }

        self.quickSort();
        self
    }

    pub fn sort2[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }

        self.quickSort2();
        self
    }

    fn quickSort[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }
        let p = self.partition();
        let left = self.subSlice(0, p);
        let right = self.subSlice(p + 1, self.len());
        left.quickSort();
        right.quickSort();
        self
    }

    fn partition[T: Ord[T]](mut self) -> (Self, Int) {
        let lo = 0;
        let hi = self.len() - 1;
        let pivot = self.getUnchecked(hi);
        let mut i = lo - 1;
        for j in lo..hi {
            if self.getUnchecked(j) <= pivot {
                i += 1;
                self.swap(i, j);
            }
        }
        self.swap(i + 1, hi);
        (self, i + 1)
    }

    fn quickSort2[T: Ord[T]](mut self) -> Self {
        if self.len() <= 1 {
            return self;
        }

        let (lt, gt) = self.partition3();

        // Recursively sort < pivot
        self.subSlice(0, lt).quickSort();

        // Recursively sort > pivot
        self.subSlice(gt + 1, self.len()).quickSort();

        self
    }

    fn partition3[T: Ord[T]](mut self) -> (Self, Int, Int) {
        let lo = 0;
        let hi = self.len() - 1;
        let pivot = self.getUnchecked(lo); // pick first element as pivot

        let mut lt = lo;   // end of < pivot region
        let mut gt = hi;   // start of > pivot region
        let mut i  = lo;   // current element

        while i <= gt {
            if self.getUnchecked(i) < pivot {
                self.swap(lt, i);
                lt += 1;
                i += 1;
            } else if self.getUnchecked(i) > pivot {
                self.swap(i, gt);
                gt -= 1;
                // dont increment i, need to examine swapped element
            } else {
                i += 1; // equal to pivot
            }
        }

        (self, lt, gt) // indices of first == pivot and last == pivot
    }

    pub fn reverse(mut self) -> Self {
        let mut i = 0;
        let mut j = self.len() - 1;
        while i < j {
            self.swap(i, j);
            i += 1;
            j -= 1;
        }
        self
    }
}

}
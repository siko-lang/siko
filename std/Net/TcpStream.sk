module Net.TcpStream {

import Libc.FileDescriptor
import Libc.Socket
import Libc.String
import Libc.Errno
import Libc.Unistd
import Int.Util
import IO.Error
import IO.Buffer
import IO.Reader
import IO.Writer

pub struct TcpStream {
    sock: FileDescriptor,

    @safe
    pub fn connect(addr: &String) -> Result[TcpStream, Error] {
        let (ip, port) = try splitHostPort(addr);
        let sock = try createSocket(AF_INET, SOCK_STREAM);
        let sockAddrIn = Libc.Socket.SockaddrIn.new(AF_INET, port, 0.toU32());
        try parseAddress(ip, AF_INET, sockAddrIn.addrPtr());
        try connectSocket(sock, sockAddrIn);
        Ok(TcpStream(sock: FileDescriptor.new(sock)))
    }

    fn splitHostPort(addr: &String) -> Result[(String, U16), Error] {
        let mut parts = addr.split(':');
        if parts.len() != 2 {
            return Err(Error.new(-1));
        }
        let ipPart = parts.remove(0);
        let portPart = parts.remove(0);
        let port = parseNum(portPart).unwrap();
        Ok((ipPart, port.toU16()))
    }

    @unsafe
    fn createSocket(domain: Domain, ty: SockType) -> Result[I32, Error] {
        let sock = Libc.Socket.socket(domain.code(), ty.code(), 0.toI32());
        if sock < 0.toI32() {
            let err = getErrno();
            println("Err ${err.toInt()}");
            return Err(Error.new(err.toInt()));
        }
        Ok(sock)
    }

    @unsafe
    fn parseAddress(addr: String, domain: Domain, inAddr: *Libc.Socket.InAddr) -> Result[(), Error] {
        let addrCStr = CString.fromString(addr);
        let res = inet_pton(domain.code(), addrCStr.asPtr(), inAddr);
        if res <= 0.toI32() {
            let err = getErrno();
            return Err(Error.new(err.toInt()));
        }
        Ok(())
    }

    @unsafe
    fn connectSocket(sock: I32, sockAddrIn: &Libc.Socket.SockaddrIn) -> Result[(), Error] {
        let res = Libc.Socket.connect(sock, sockAddrIn.asPtr(), sockAddrIn.len());
        if res < 0.toI32() {
            let err = getErrno();
            return Err(Error.new(err.toInt()));
        }
        Ok(())
    }
}

pub instance TcpReader Reader[TcpStream] {
    fn read(&self, buffer: &WriteBuffer) -> Result[Int, Error] {
        self.sock.read(buffer)
    }
}

pub instance TcpWriter Writer[TcpStream] {
    fn write(&self, buffer: &ReadBuffer) -> Result[Int, Error] {
        self.sock.write(buffer)
    }
}

}
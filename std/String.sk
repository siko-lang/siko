module String {

import NativePtr
import Slice
import Std.Ops

pub struct String {
    value: *U8,
    size: U64,
    capacity: U64,

    pub fn new() -> String {
        String(null(), 0.toU64(), 0.toU64())
    }

    pub fn withCapacity(capacity: Int) -> String {
        let value = allocateArray(capacity.toU64());
        String(value, 0.toU64(), capacity.toU64())
    }

    pub fn len(&self) -> Int {
        self.size.toInt()
    }

    pub fn eq(&self, other: &String) -> Bool {
        if self.size != other.size {
            return False;
        }
        let result = NativePtr.memcmp(self.value, other.value, self.size);
        result == 0
    }

    pub fn clone(&self) -> String {
        if self.capacity == 0.toU64() {
            return String(self.value, self.size, self.capacity);
        } else {
            let newValue = allocateArray(self.capacity);
            memcpy(newValue, self.value, self.size);
            String(newValue, self.size, self.capacity)
        }
    }

    pub fn push(self, other: &String) -> Self {
        self + other
    }

    pub fn pushChar(self, c: U8) -> Self {
        let newCapacity = self.size + 1.toU64();
        let newValue = allocateArray(newCapacity);
        memcpy(newValue, self.value, self.size);
        *offset(newValue, self.size) = c;
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        String(newValue, newCapacity, newCapacity)
    }

    pub fn reverse(mut self) -> Self {
        self.slice().reverse();
        self
    }

    pub fn slice(&self) -> Slice[U8] {
        Slice.new(self.value, self.size)
    }

    pub fn fromU8(value: Vec[U8]) -> String {
        let capacity = value.len().toU64();
        let newValue = allocateArray(capacity);
        memcpy(newValue, value.asPtr(), capacity);
        String(newValue, capacity, capacity)
    }
}

pub instance Drop[String] {
    fn drop(mut self) -> Self {
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        self.capacity = 0.toU64();
        self.size = 0.toU64();
        self.value = null();
        self
    }
}

pub instance AddString Add[String, String] {
    type Output = String
    fn add(self, other: String) -> String {
        self + &other
    }
}

pub instance AddStringLiteral Add[String, StringLiteral] {
    type Output = String
    fn add(self, other: StringLiteral) -> String {
        self + other.toString()
    }
}

pub instance AddStringRef Add[String, &String] {
    type Output = String
    fn add(self, other: &String) -> String {
        let newCapacity = self.size + other.size;
        let newValue = allocateArray(newCapacity);
        memcpy(newValue, self.value, self.size);
        memcpy(offset(newValue, self.size), other.value, other.size);
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        String(newValue, newCapacity, newCapacity)
    }
}

pub instance PartialEqString PartialEq[String] {
    fn eq(&self, other: &String) -> Bool {
        self.eq(other)
    }
}

pub instance CloneString Clone[String] {
    fn clone(&self) -> String {
        self.clone()
    }
}

pub instance ShowString Show[String] {
    fn show(&self) -> String {
        self.clone()
    }
}

pub struct StringLiteral {
    value: *U8,
    size: U64,

    pub fn new(value: *U8, size: U64) -> StringLiteral {
        StringLiteral(value, size)
    }

    pub fn len(&self) -> Int {
        self.size.toInt()
    }

     pub fn slice(&self) -> Slice[U8] {
        Slice.new(self.value, self.size)
    }

    pub fn clone(&self) -> StringLiteral {
        StringLiteral(self.value, self.size)
    }

    pub fn toString(&self) -> String {
        String(self.value, self.size, 0.toU64())
    }
}

pub instance CloneStringLiteral Clone[StringLiteral] {
    fn clone(&self) -> StringLiteral {
        self.clone()
    }
}

pub instance PartialEqStringLiteral PartialEq[StringLiteral] {
    fn eq(&self, other: &StringLiteral) -> Bool {
        self.toString().eq(&other.toString())
    }
}

pub instance ImplicitConvertStringLiteral ImplicitConvert[StringLiteral, String] {
    fn implicitConvert(self) -> String {
        self.toString()
    }
}

pub instance CopyStringLiteral Copy[StringLiteral]

pub instance AddStringLiterals Add[StringLiteral, StringLiteral] {
    type Output = String
    fn add(self, other: StringLiteral) -> String {
        self.toString() + other.toString()
    }
}

pub instance AddStringLiteralStringRef Add[StringLiteral, &String] {
    type Output = String
    fn add(self, other: &String) -> String {
        self.toString() + other
    }
}

pub instance AddStringLiteralString Add[StringLiteral, String] {
    type Output = String
    fn add(self, other: String) -> String {
        self.toString() + other
    }
}

pub instance ShowStringLiteral Show[StringLiteral] {
    fn show(&self) -> String {
        self.toString()
    }
}

}

module NativePtr {

import Libc.String as Mem
import Allocator
import Int.Util

pub fn sizeOf[T](addr: *T) -> U64 = extern

pub fn transmute[T, U](v: T) -> U = extern

@unsafe
pub fn eq[T](a: *T, b: *T) -> Bool {
    toU64(a) == toU64(b)
}

@unsafe
pub fn null[T]() -> *T {
    transmute(0)
}

@unsafe
pub fn isNullPtr[T](addr: *T) -> Bool {
    toU64(addr) == 0.toU64()
}

@unsafe
pub fn allocateArray[T](count: U64) -> *T {
    let p: *T = null();
    Allocator.allocate(count * sizeOf(p))
}

@unsafe
pub fn allocate[T]() -> *T {
    allocateArray(1.toU64())
}

@unsafe
pub fn deallocate[T](addr: *T) {
    Allocator.deallocate(addr);
}

@unsafe
pub fn memcpy[T](dest: *T, src: *T, count: U64) {
    Mem.memcpy(dest, src, count * sizeOf(src));
}

@unsafe
pub fn memmove[T](dest: *T, src: *T, count: U64) {
    Mem.memmove(dest, src, count * sizeOf(src));
}

@unsafe
pub fn memcmp[T](dest: *T, src: *T, count: U64) -> Int {
    Mem.memcmp(dest, src, count * sizeOf(src)).toInt()
}

@unsafe
pub fn offset[T](base: *T, count: U64) -> *T {
    let size = sizeOf(base);
    let v: U64 = toU64(base) + (count * size);
    transmute(v)
}

@unsafe
pub fn toRef[T](addr: *T) -> &T {
    let v: &T = transmute(addr);
    v
}

@unsafe
pub fn toPtr[T](addr: &T) -> *T {
    let v: *T = transmute(addr);
    v
}

@unsafe
pub fn clone[T](addr: &*T) -> *T {
    *toPtr(addr)
}

@unsafe
pub fn toU64[T](addr: &*T) -> U64 {
    transmute(clone(addr))
}

@unsafe
pub fn voidPtrToU64(addr: void*) -> U64 {
    let addr: U64 = transmute(addr);
    addr
}

@unsafe
pub fn printPtr[T](addr: &*T) {
    // helper function to print pointer value for debugging
    // without allocation
    // if/when the compiler supports inline string building, this can be replaced

    let v = toU64(addr);
    let digits = v.toHexVec();
    let s = digits.slice();
    let literal = StringLiteral.new(s.asPtr(), s.len());
    printLiteral("pointer:");
    printLiteral(literal);
    printLiteral("\n");
}

pub instance[T] ShowPtr Show[*T] {
    @unsafe
    fn show(addr: &*T) -> String {
        let v = toU64(addr);
        v.toHex()
    }
    @unsafe
    fn toString(addr: &*T) -> String {
        show(addr)
    }
}

pub instance[T] ShowVoidPtr Show[void*] {
    @unsafe
    fn show(&self) -> String {
        let addr = voidPtrToU64(self.clone());
        addr.toHex()
    }

    @unsafe
    fn toString(&self) -> String {
        show(self)
    }
}

pub instance[T] PartialEqPtr PartialEq[*T] {
    @unsafe
    fn eq(a: &*T, b: &*T) -> Bool {
        NativePtr.eq(a, b)
    }

    @unsafe
    fn ne(a: &*T, b: &*T) -> Bool {
        !NativePtr.eq(a, b)
    }
}

pub instance[T] PtrClone Clone[*T] {
    @unsafe
    fn clone(addr: &*T) -> *T {
        NativePtr.clone(addr)
    }
}

pub instance[T] PtrCopy Copy[*T]

pub trait Nullable[T] {
    fn isNull(&self) -> Bool
}

pub instance[T] NullablePtr Nullable[*T] {
    @unsafe
    fn isNull(&self) -> Bool {
        let addr: *T = clone(self);
        isNullPtr(addr)
    }
}

pub instance NullableVoidPtr Nullable[void*] {
    @unsafe
    fn isNull(&self) -> Bool {
        let addr = voidPtrToU64(self.clone());
        addr == 0.toU64()
    }
}

pub instance CloneVoidPtr Clone[void*] {
    @unsafe
    fn clone(&self) -> void* {
        let addr: *void* = transmute(self);
        let v: void* = *addr;
        v
    }
}

}
module String {

import NativePtr
import Slice
import Std.Ops

pub struct String {
    value: *U8,
    size: U64,
    capacity: U64,

    @safe
    pub fn new() -> String {
        String(null(), 0.toU64(), 0.toU64())
    }

    pub fn len(&self) -> Int {
        self.size.toInt()
    }

    @safe
    pub fn eq(&self, other: &String) -> Bool {
        if self.size != other.size {
            return False;
        }
        let result = NativePtr.memcmp(self.value, other.value, self.size);
        result == 0
    }

    @safe
    pub fn clone(&self) -> String {
        if self.capacity == 0.toU64() {
            return String(self.value, self.size, self.capacity);
        } else {
            let newValue = allocateArray(self.capacity);
            memcpy(newValue, self.value, self.size);
            String(newValue, self.size, self.capacity)
        }
    }

    pub fn push(self, other: &String) -> Self {
        self + other
    }

    @safe
    pub fn pushChar(mut self, c: U8) -> Self {
        let newCapacity = self.size + 1.toU64();
        let newValue = allocateArray(newCapacity);
        memcpy(newValue, self.value, self.size);
        *offset(newValue, self.size) = c;
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        self.value = newValue;
        self.size = newCapacity;
        self.capacity = newCapacity;
        self
    }

    @safe
    pub fn reverse(mut self) -> Self {
        self.slice().reverse();
        self
    }

    @unsafe
    pub fn slice(&self) -> Slice[U8] {
        Slice.new(self.value, self.size)
    }

    @safe
    pub fn fromU8(value: Slice[U8]) -> String {
        let capacity = value.len();
        if capacity == 0.toU64() {
            return String(null(), 0.toU64(), 0.toU64());
        }
        let newValue = allocateArray(capacity);
        memcpy(newValue, value.asPtr(), capacity);
        String(newValue, capacity, capacity)
    }

    @safe
    pub fn appendSlice(mut self, slice: Slice[U8]) -> Self {
        let tmp = String(slice.asPtr(), slice.len(), 0.toU64()); // capacity 0 means no deallocation
        self.push(tmp);
        self
    }

    @safe
    pub fn split(&self, delimiter: U8) -> Vec[String] {
        let mut parts = Vec.new();
        let mut start = 0.toU64();
        for i in 0.toU64() .. self.size {
            if *offset(self.value, i) == delimiter {
                let partSlice = Slice.new(offset(self.value, start), i - start);
                parts.push(String.fromU8(partSlice));
                start = i + 1.toU64();
            }
        }
        if start < self.size {
            let partSlice = Slice.new(offset(self.value, start), self.size - start);
            parts.push(String.fromU8(partSlice));
        }
        parts
    }

    @safe
    pub fn toVecU8(mut self) -> Vec[U8] {
        if self.capacity == 0.toU64() {
            if self.size == 0.toU64() {
                return Vec.new();
            }
            // string literal, copy to new buffer
            let s = fromU8(self.slice());
            return s.toVecU8();
        }
        let v = Vec.fromSlice(self.slice());
        self.capacity = 0.toU64();
        self.value = null();
        self.size = 0.toU64();
        v
    }

    @safe
    pub fn fromVecU8(v: Vec[U8]) -> String {
        let slice = v.intoSlice();
        String(slice.asPtr(), slice.len(), slice.len())
    }

    @safe
    pub fn endsWith(&self, suffix: &String) -> Bool {
        if suffix.size > self.size {
            return False;
        }
        let start = self.size - suffix.size;
        let result = NativePtr.memcmp(offset(self.value, start), suffix.value, suffix.size);
        result == 0
    }

    @safe
    pub fn startsWith(&self, prefix: &String) -> Bool {
        if prefix.size > self.size {
            return False;
        }
        let result = NativePtr.memcmp(self.value, prefix.value, prefix.size);
        result == 0
    }

    @safe
    pub fn findLast(&self, c: U8) -> Option[U64] {
        for i in 0.toU64()..self.size {
            let index = self.size - 1.toU64() - i;
            if *NativePtr.offset(self.value, index) == c {
                return Some(index);
            }
        }
        None
    }

    @safe
    pub fn subString(&self, start: U64, end: U64) -> String {
        if start >= self.size or end > self.size or start >= end {
            panic("Invalid substring range");
        }
        let len = end - start;
        let newValue = allocateArray(len);
        memcpy(newValue, offset(self.value, start), len);
        String(newValue, len, len)
    }

    @safe
    pub fn contains(&self, other: &String) -> Bool {
        if other.size > self.size {
            return False;
        }
        for i in 0.toU64() .. (self.size - other.size + 1.toU64()) {
            let result = NativePtr.memcmp(offset(self.value, i), other.value, other.size);
            if result == 0 {
                return True;
            }
        }
        False
    }
}

pub instance Drop[String] {
    @unsafe
    fn drop(mut self) -> Self {
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        self.capacity = 0.toU64();
        self.size = 0.toU64();
        self.value = null();
        self
    }
}

pub instance AddString Add[String, String] {
    type Output = String
    fn add(self, other: String) -> String {
        self + &other
    }
}

pub instance AddStringLiteral Add[String, StringLiteral] {
    type Output = String
    fn add(self, other: StringLiteral) -> String {
        self + other.toString()
    }
}

pub instance AddStringRef Add[String, &String] {
    type Output = String

    @safe
    fn add(self, other: &String) -> String {
        let newCapacity = self.size + other.size;
        let newValue = allocateArray(newCapacity);
        memcpy(newValue, self.value, self.size);
        memcpy(offset(newValue, self.size), other.value, other.size);
        if self.capacity > 0.toU64() {
            NativePtr.deallocate(self.value);
        }
        String(newValue, newCapacity, newCapacity)
    }
}

pub instance PartialEqString PartialEq[String] {
    fn eq(&self, other: &String) -> Bool {
        self.eq(other)
    }
}

pub instance EqString Eq[String]

pub instance PartialOrdString PartialOrd[String] {
    @safe
    fn partialCmp(&self, other: &String) -> Option[Ordering] {
        let minSize = if self.size < other.size { self.size } else { other.size };
        let result = NativePtr.memcmp(self.value, other.value, minSize);
        if result < 0 {
            Some(Ordering.Less)
        } else if result > 0 {
            Some(Ordering.Greater)
        } else {
            if self.size < other.size {
                Some(Ordering.Less)
            } else if self.size > other.size {
                Some(Ordering.Greater)
            } else {
                Some(Ordering.Equal)
            }
        }
    }
}

pub instance OrdString Ord[String] {
    fn cmp(&self, other: &String) -> Ordering {
        match self.partialCmp(other) {
            Some(ordering) -> ordering,
            None -> panic("Cannot compare strings")
        }
    }
}

pub instance CloneString Clone[String] {
    fn clone(&self) -> String {
        self.clone()
    }
}

pub instance ShowString Show[String] {
    fn show(&self) -> String {
        self.clone()
    }
}

pub struct StringLiteral {
    value: *U8,
    size: U64,

    pub fn new(value: *U8, size: U64) -> StringLiteral {
        StringLiteral(value, size)
    }

    pub fn len(&self) -> Int {
        self.size.toInt()
    }

    @unsafe
    pub fn slice(&self) -> Slice[U8] {
        Slice.new(self.value, self.size)
    }

    @safe
    pub fn clone(&self) -> StringLiteral {
        StringLiteral(self.value, self.size)
    }

    @safe
    pub fn toString(&self) -> String {
        String(self.value, self.size, 0.toU64())
    }
}

pub instance CloneStringLiteral Clone[StringLiteral] {
    fn clone(&self) -> StringLiteral {
        self.clone()
    }
}

pub instance PartialEqStringLiteral PartialEq[StringLiteral] {
    fn eq(&self, other: &StringLiteral) -> Bool {
        self.toString().eq(&other.toString())
    }
}

pub instance EqStringLiteral Eq[StringLiteral]

pub instance PartialOrdStringLiteral PartialOrd[StringLiteral] {
    fn partialCmp(&self, other: &StringLiteral) -> Option[Ordering] {
        self.toString().partialCmp(&other.toString())
    }
}

pub instance OrdStringLiteral Ord[StringLiteral] {
    fn cmp(&self, other: &StringLiteral) -> Ordering {
        self.toString().cmp(&other.toString())
    }
}

pub instance ImplicitConvertStringLiteral ImplicitConvert[StringLiteral, String] {
    fn implicitConvert(self) -> String {
        self.toString()
    }
}

pub instance CopyStringLiteral Copy[StringLiteral]

pub instance AddStringLiterals Add[StringLiteral, StringLiteral] {
    type Output = String
    fn add(self, other: StringLiteral) -> String {
        self.toString() + other.toString()
    }
}

pub instance AddStringLiteralStringRef Add[StringLiteral, &String] {
    type Output = String
    fn add(self, other: &String) -> String {
        self.toString() + other
    }
}

pub instance AddStringLiteralString Add[StringLiteral, String] {
    type Output = String
    fn add(self, other: String) -> String {
        self.toString() + other
    }
}

pub instance ShowStringLiteral Show[StringLiteral] {
    fn show(&self) -> String {
        self.toString()
    }
}

@test
fn splitStringTest() {
    let s = "a,b,c".toString();
    let parts = s.split(',');
    assert(parts.len() == 3);
    assert(parts.get(0) == "a".toString());
    assert(parts.get(1) == "b".toString());
    assert(parts.get(2) == "c".toString());
}

}

module Sync.Atomic {

import NativePtr

pub struct AtomicU32 {
    value: U32
    pub fn new(value: U32) -> AtomicU32 {
        AtomicU32(value: value)
    }

    @safe
    pub fn load(&self, order: MemoryOrder = MemoryOrder.SEQ_CST) -> U32 {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_load_n(ptr, order.discriminator().toU8())
    }

    @safe
    pub fn store(&self, value: U32, order: MemoryOrder = MemoryOrder.SEQ_CST) {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_store_n(ptr, value, order.discriminator().toU8());
    }

    @safe
    pub fn fetchAdd(&self, value: U32, order: MemoryOrder = MemoryOrder.SEQ_CST) -> U32 {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_fetch_add(ptr, value, order.discriminator().toU8())
    }

    @safe
    pub fn fetchSub(&self, value: U32, order: MemoryOrder = MemoryOrder.SEQ_CST) -> U32 {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_fetch_sub(ptr, value, order.discriminator().toU8())
    }

    @safe
    pub fn addFetch(&self, value: U32, order: MemoryOrder = MemoryOrder.SEQ_CST) -> U32 {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_add_fetch(ptr, value, order.discriminator().toU8())
    }

    @safe
    pub fn subFetch(&self, value: U32, order: MemoryOrder = MemoryOrder.SEQ_CST) -> U32 {
        let ptr = NativePtr.toPtr(&self.value);
        __atomic_sub_fetch(ptr, value, order.discriminator().toU8())
    }
}

@derive(Discriminator)
pub enum MemoryOrder {
    RELAXED
    CONSUME
    ACQUIRE
    RELEASE
    ACQ_REL
    SEQ_CST
}

fn __atomic_load_n(ptr: *U32, order: U8) -> U32 = extern "C" ("stdatomic.h")
fn __atomic_store_n(ptr: *U32, value: U32, order: U8) = extern "C" ("stdatomic.h")
fn __atomic_fetch_add(ptr: *U32, value: U32, order: U8) -> U32 = extern "C" ("stdatomic.h")
fn __atomic_fetch_sub(ptr: *U32, value: U32, order: U8) -> U32 = extern "C" ("stdatomic.h")
fn __atomic_add_fetch(ptr: *U32, value: U32, order: U8) -> U32 = extern "C" ("stdatomic.h")
fn __atomic_sub_fetch(ptr: *U32, value: U32, order: U8) -> U32 = extern "C" ("stdatomic.h")

pub struct AtomicBool {
    value: AtomicU32

    fn boolToU32(value: Bool) -> U32 {
        if value {
            return 1.toU32();
        } else {
            return 0.toU32();
        }
    }

    pub fn new(value: Bool) -> AtomicBool {
        let intValue: U32 = boolToU32(value);
        AtomicBool(value: AtomicU32.new(intValue))
    }

    pub fn load(&self, order: MemoryOrder = MemoryOrder.SEQ_CST) -> Bool {
        let intValue = self.value.load(order);
        return intValue != 0.toU32();
    }

    pub fn store(&self, value: Bool, order: MemoryOrder = MemoryOrder.SEQ_CST) {
        let intValue: U32 = boolToU32(value);
        self.value.store(intValue, order);
    }
}

}
module Sync.Thread {

import Arch.Pthread
import Libc.Pthread
import Libc.Unistd
import NativePtr

struct Arg {
    f: fn() -> ()
}

pub struct JoinHandle {
    thread: PThread,

    pub fn new(thread: PThread) -> JoinHandle {
        JoinHandle(thread: thread)
    }

    @safe
    pub fn join(self) {
        pthread_join(self.thread, null());
    }
}

@unsafe
fn entrypoint(arg: void*) -> void* {
    let argPtr: *Arg = transmute(arg);
    let f = argPtr.f;
    NativePtr.deallocate(argPtr);
    f();
    let nil: *void = null();
    return nil;
}

@safe
pub fn spawn(f: fn() -> ()) -> JoinHandle {
    let thread = PThread.new();
    let attr = PthreadAttr.new();
    let arg = Arg(f: f);
    let argPtr: *Arg = NativePtr.allocate();
    *argPtr = arg;
    let attr = &raw attr;
    pthread_attr_init(attr);
    pthread_create(&raw thread, attr, entrypoint, argPtr);
    JoinHandle.new(thread)
}

@safe
pub fn sleep(microseconds: U32) {
    Libc.Unistd.usleep(microseconds);
}

pub struct Mutex {
    inner: Arch.Pthread.Mutex,

    @safe
    pub fn new() -> Mutex {
        let mutexAttr = Arch.Pthread.MutexAttr.new();
        if pthread_mutexattr_init(&raw mutexAttr) != 0.toI32() {
            panic("Failed to initialize mutex attributes");
        }
        let mutex = Arch.Pthread.Mutex.new();
        if pthread_mutex_init(&raw mutex, &raw mutexAttr) != 0.toI32() {
            panic("Failed to initialize mutex");
        }
        Mutex(inner: mutex)
    }

    @safe
    pub fn lock(&self) {
        pthread_mutex_lock(&raw self.inner);
    }

    @safe
    pub fn unlock(&self) {
        pthread_mutex_unlock(&raw self.inner);
    }
}

}
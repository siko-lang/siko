@prelude
module Int {

import Convert
import NativePtr
import Std.Ops
import Int.Util

@builtin
pub struct Int {
    pub fn add(self, other: Int) -> Int = extern

    pub fn sub(self, other: Int) -> Int = extern

    pub fn mul(self, other: Int) -> Int = extern

    pub fn div(self, other: Int) -> Int = extern

    pub fn mod(self, other: Int) -> Int = extern

    pub fn eq(&self, other: &Int) -> Bool = extern

    pub fn lessThan(&self, other: &Int) -> Bool = extern

    @safe
    pub fn toU8(&self) -> U8 {
        transmute(self.clone())
    }

    @safe
    pub fn toI8(&self) -> I8 {
        transmute(self.clone())
    }

    @safe
    pub fn toU16(&self) -> U16 {
        transmute(self.clone())
    }

    @safe
    pub fn toU32(&self) -> U32 {
        transmute(self.clone())
    }

    @safe
    pub fn toU64(&self) -> U64 {
        transmute(self.clone())
    }

    @safe
    pub fn toI64(&self) -> I64 {
        transmute(self.clone())
    }

    @safe
    pub fn toI32(&self) -> I32 {
        transmute(self.clone())
    }

    @safe
    pub fn clone(&self) -> Int {
        *toPtr(self)
    }
}

pub instance AddInt Add[Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

pub instance AddIntRef Add[Int, &Int] {
    type Output = Int
    fn add(self, other: &Int) -> Int {
        self.add(other.clone())
    }
}


pub instance AddRefInt Add[&Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

pub instance SubInt Sub[Int, Int] {
    type Output = Int
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

pub instance SubRefInt Sub[&Int, Int] {
    type Output = Int
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

pub instance MulInt Mul[Int, Int] {
    type Output = Int
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

pub instance MulRefInt Mul[&Int, Int] {
    type Output = Int
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

pub instance DivInt Div[Int, Int] {
    type Output = Int
    fn div(self, other: Int) -> Int {
        self.div(other)
    }
}

pub instance PartialEqInt PartialEq[Int] {
    fn eq(&self, other: &Int) -> Bool {
        self.eq(other)
    }
}

pub instance EqInt Eq[Int]

pub instance PartialOrdInt PartialOrd[Int] {
    fn partialCmp(&self, other: &Int) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdInt Ord[Int] {
    fn cmp(&self, other: &Int) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneInt Clone[Int] {
    fn clone(&self) -> Int {
        self.clone()
    }
}

pub instance CopyInt Copy[Int]

pub instance NegInt Neg[Int] {
    fn negative(self) -> Int {
        0 - self
    }
}

pub instance ShowInt Show[Int] {
    fn show(&self) -> String {
        showNum(self)
    }
}

pub instance ModInt Mod[Int] {
    fn mod(&self, other: &Int) -> Int {
        self.mod(other)
    }
}

pub instance IntoIntInt Into[Int, Int] {
    fn into(self) -> Int {
        self.clone()
    }
}

pub instance FromIntInt From[Int, Int] {
    fn from(s: Int) -> Int {
        s
    }
}

@test
fn testAdd() {
    let a: Int = 10;
    let b: Int = 20;
    let c = a + b;
    assert(c == 30);
}


@test
fn testSub() {
    let a: Int = 10;
    let b: Int = 20;
    let c = b - a;
    assert(c == 10);
}


}
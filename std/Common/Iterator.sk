@prelude
module Iterator {

pub trait Iterator[T] {
    type Item
    fn next(self) -> (Self, Option[Item])

    fn enumerate(self) -> Enumerate[T] {
        Enumerate(self, 0.toU64())
    }

    fn map[U](self, f: fn(Item) -> U) -> MapIter[Item, U, T] {
        MapIter (iter: self, f: f)
    }

    fn collect[C: FromIterator[C, Item]](self) -> C {
        FromIterator.fromIterator(self)
    }

    fn skip(self, n: Int) -> SkipIter[T] {
        SkipIter (iter: self, n: n)
    }
}

pub trait IntoIterator[T] {
    type Item
    type Iter: Iterator[Iter, Item=Item]

    fn intoIterator(self) -> Iter
}

pub instance[T, I: Iterator[T, Item=I]] IteratorIntoIterator IntoIterator[T] {
    type Item = I
    type Iter = T

    fn intoIterator(self) -> T {
        self
    }
}

pub struct Enumerate[T] {
    iter: T,
    index: U64
}

pub instance[T, E: Iterator[T, Item=E]] EnumerateIterator Iterator[Enumerate[T]] {
    type Item = (U64, E)

    fn next(mut self) -> (Self, Option[(U64, E)]) {
        let item = self.iter.next();
        match item {
            Some(item) -> {
                let result = (self.index, item);
                self.index += 1.toU64();
                (self, Some(result))
            }
            None -> {
                (self, None)
            }
        }
    }
}

pub struct MapIter[T, U, I] {
    iter: I,
    f: fn(T) -> U
}

pub instance[T, U, I: Iterator[I, Item=T]] MapIterator Iterator[MapIter[T, U, I]] {
    type Item = U

    fn next(mut self) -> (Self, Option[U]) {
        let item =  self.iter.next();
        match item {
            Some(item) -> {
                let f = self.f;
                let result = f(item);
                (self, Some(result))
            }
            None -> {
                (self, None)
            }
        }
    }
}

pub trait FromIterator[T, I] {
    fn fromIterator[S, Iter: IntoIterator[S, Item=I, Iter=Iter]](iter: S) -> T
    //fn fromIterator[S: Iterator[S, Item=I]](iter: S) -> T
}

pub struct SkipIter[I] {
    iter: I,
    n: Int
}

pub instance[T, I: Iterator[I, Item=T]] SkipIterator Iterator[SkipIter[I]] {
    type Item = T

    fn next(mut self) -> (Self, Option[T]) {
        while self.n > 0 {
            self.iter.next();
            self.n -= 1;
        }
        let item = self.iter.next();
        (self, item)
    }
}

}

@prelude
module Iterator {

pub trait Iterator[T] {
    type Item
    fn next(self) -> (Self, Option[Item])

    fn enumerate(self) -> Enumerate[T] {
        Enumerate(self, 0.toU64())
    }

    fn map[U](self, f: fn(Item) -> U) -> MapIter[Item, U, T] {
        MapIter (iter: self, f: f)
    }

    fn collect[C: FromIterator[C, Item]](self) -> C {
        FromIterator.fromIterator(self)
    }
}

pub trait IntoIterator[T] {
    type Item
    type Iter: Iterator[Iter, Item=Item]

    fn intoIterator(self) -> Iter
}

pub instance[T, I: Iterator[T, Item=I]] IteratorIntoIterator IntoIterator[T] {
    type Item = I
    type Iter = T

    fn intoIterator(self) -> T {
        self
    }
}

pub struct Enumerate[T] {
    iter: T,
    index: U64
}

pub instance[T, E: Iterator[T, Item=E]] Iterator[Enumerate[T]] {
    type Item = (U64, E)

    fn next(self) -> (Self, Option[(U64, E)]) {
        let (newIter, itemOpt) = self.iter.next();
        match itemOpt {
            Some(item) -> {
                let result = (self.index, item);
                let newEnumerate = Enumerate(newIter, self.index + 1.toU64());
                (newEnumerate, Some(result))
            }
            None -> {
                (Enumerate(newIter, self.index), None)
            }
        }
    }
}

pub struct MapIter[T, U, I] {
    iter: I,
    f: fn(T) -> U
}

pub instance[T, U, I: Iterator[I, Item=T]] Iterator[MapIter[T, U, I]] {
    type Item = U

    fn next(self) -> (Self, Option[U]) {
        let (newIter, itemOpt) = self.iter.next();
        match itemOpt {
            Some(item) -> {
                let f = self.f;
                let result = f(item);
                (MapIter (iter: newIter, f: f), Some(result))
            }
            None -> {
                (MapIter (iter: newIter, f: self.f), None)
            }
        }
    }
}

pub trait FromIterator[T, I] {
    fn fromIterator[S, Iter: IntoIterator[S, Item=I, Iter=Iter]](iter: S) -> T
    //fn fromIterator[S: Iterator[S, Item=I]](iter: S) -> T
}

}

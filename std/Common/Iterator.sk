module Iterator {

pub struct Enumerate[T] {
    iter: T,
    index: U64
}

pub instance[T, E: Iterator[T, Item=E]] Iterator[Enumerate[T]] {
    type Item = (U64, E)

    fn next(self) -> (Self, Option[(U64, E)]) {
        let (newIter, itemOpt) = self.iter.next();
        match itemOpt {
            Some(item) -> {
                let result = (self.index, item);
                let newEnumerate = Enumerate(newIter, self.index + 1.toU64());
                (newEnumerate, Some(result))
            }
            None -> {
                (Enumerate(newIter, self.index), None)
            }
        }
    }
}

pub trait Iterator[T] {
    type Item
    fn next(self) -> (Self, Option[Item])

    fn enumerate(self) -> Enumerate[T] {
        Enumerate(self, 0.toU64())
    }
}

pub trait IntoIterator[T] {
    type Item
    type Iter: Iterator[Iter, Item=Item]

    fn intoIterator(self) -> Iter
}

pub instance[T, I: Iterator[T, Item=I]] IteratorIntoIterator IntoIterator[T] {
    type Item = I
    type Iter = T

    fn intoIterator(self) -> T {
        self
    }
}

}
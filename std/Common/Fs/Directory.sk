module Fs.Directory {

import Arch.Dirent
import Arch.Errno
import IO.Error
import Libc.Dir
import Libc.String
import NativePtr

pub struct Directory {
    dir: void*,

    @safe
    pub fn open(path: &String) -> Result[Directory, Error] {
        let cPath = CString.fromString(path.clone());
        let dirPtr = Libc.Dir.opendir(cPath.asPtr());
        if dirPtr.isNull() {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        let dir = Fs.Directory.Directory(dir: dirPtr);
        Ok(dir)
    }

    @safe
    pub fn read(&self) -> Result[Option[DirEntry], Error] {
        setErrnoCode(0);
        let entryPtr = Libc.Dir.readdir(self.dir.clone());
        if entryPtr.isNull() {
            let err = Arch.Errno.getErrnoCode();
            if err == 0 {
                return Ok(None);
            }
            return Err(Error.new(err));
        }
        Ok(Some(DirEntry.fromDirent(entryPtr)))
    }

    @unsafe
    fn close(&self) -> Result[(), Error] {
        if self.dir.isNull() {
            return Ok(());
        }
        let res = Libc.Dir.closedir(self.dir.clone());
        if res < 0.toI32() {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        Ok(())
    }
}

@derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy)
pub enum FileType {
    Unknown
    Fifo,
    CharDevice,
    Directory,
    BlockDevice,
    RegularFile,
    Symlink,
    Socket,
    Whiteout,

    fn fromU8(value: U8) -> FileType {
        match value.toInt() {
            0 -> Unknown,
            1 -> Fifo,
            2 -> CharDevice,
            4 -> FileType.Directory,
            6 -> BlockDevice,
            8 -> RegularFile,
            10 -> Symlink,
            12 -> Socket,
            14 -> Whiteout,
            _ -> Unknown,
        }
    }
}

pub instance Show[FileType] {
    fn show(&self) -> String {
        let s = match self {
            Unknown -> "Unknown",
            Fifo -> "Fifo",
            CharDevice -> "CharDevice",
            FileType.Directory -> "Directory",
            BlockDevice -> "BlockDevice",
            RegularFile -> "RegularFile",
            Symlink -> "Symlink",
            Socket -> "Socket",
            Whiteout -> "Whiteout",
        };
        s.toString()
    }
}

pub struct DirEntry {
    name: String,
    ty: U8,
    inode: U64,

    @unsafe
    pub fn fromDirent(entry: *Dirent) -> DirEntry {
        let entry = *entry;
        DirEntry(
            name: entry.name(),
            ty: entry.entryType(),
            inode: entry.inode(),
        )
    }

    pub fn name(&self) -> &String {
        &self.name
    }

    pub fn fileType(&self) -> FileType {
        FileType.fromU8(self.ty)
    }

    pub fn inode(&self) -> U64 {
        self.inode
    }

    pub fn isDirectory(&self) -> Bool {
        self.fileType() == FileType.Directory
    }

    pub fn isFile(&self) -> Bool {
        self.fileType() == FileType.RegularFile
    }
}

instance Drop[Directory] {
    @safe
    fn drop(self) -> Self {
        self.close();
        self
    }
}

pub struct DirEntryIterator {
    dir: Directory,
    done: Bool,

    pub fn new(path: &String) -> Result[DirEntryIterator, Error] {
        let dir = try Directory.open(path);
        Ok(DirEntryIterator(dir, done: False))
    }
}

pub instance Iterator[DirEntryIterator] {
    type Item = Result[DirEntry, Error]

    fn next(mut self) -> (Self, Option[Result[DirEntry, Error]]) {
        if self.done {
            return (self, None);
        }
        let entry = match self.dir.read() {
            Ok(Some(entry)) -> Some(Ok(entry)),
            Ok(None) -> {
                self.done = True;
                None
            }
            Err(err) -> {
                self.done = True;
                Some(Err(err))
            }
        };
        (self, entry)
    }
}

pub fn listDir(path: &String) -> Result[DirEntryIterator, Error] {
    DirEntryIterator.new(path)
}

}

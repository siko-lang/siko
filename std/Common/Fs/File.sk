module Fs.File {

import Libc.FileDescriptor
import Libc.Fcntl
import IO.Reader
import IO.Writer
import IO.Buffer
import IO.Error
import Arch.Fs

pub struct File {
    fd: FileDescriptor,

    pub fn new(fd: FileDescriptor) -> File {
        File(fd)
    }

    pub fn getFd(&self) -> I32 {
        self.fd.getFd()
    }

    pub fn create(path: &String) -> Result[File, Error] {
        let flags = O_CREAT | O_RDWR | O_TRUNC;
        let mode = 0644.toI32(); // rw-r--r--
        let fd = try Libc.Fcntl.openFile(path, flags, mode);
        Ok(File(fd: fd))
    }

    pub fn open(path: &String) -> Result[File, Error] {
        let flags = O_RDWR;
        let mode = 0.toI32();
        let fd = try Libc.Fcntl.openFile(path, flags, mode);
        Ok(File(fd: fd))
    }

    fn close(&self) -> Result[(), Error] {
        self.fd.close()
    }
}

pub instance FileReader Reader[File] {
    fn read(&self, buffer: &WriteBuffer) -> Result[Int, Error] {
        self.fd.read(buffer)
    }
}

pub instance FileWriter Writer[File] {
    fn write(&self, buffer: &ReadBuffer) -> Result[Int, Error] {
        self.fd.write(buffer)
    }
}

@safe
pub fn readFile(path: &String) -> Result[String, Error] {
    let file = try File.open(path);
    let mut result = String.new();
    let mut buffer = ByteBuffer.new(8192); // TODO: if stat is available, use file size
    loop {
        let writeBuffer = buffer.asWriteBuffer();
        let n = match file.read(&writeBuffer) {
            Ok(n) -> n,
            Err(e) -> {
                return Err(e);
            }
        };
        if n == 0 {
            break;
        }
        result.appendSlice(buffer.asSlice(n.toU64()));
    }
    Ok(result)
}

}
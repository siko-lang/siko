module Range {

import Std.Ops

pub struct Range[T] {
    start: T,
    end: T,
    inclusive: Bool,

    pub fn range[T](start: T, end: T, inclusive: Bool = False) -> Range[T] {
        Range(start, end, inclusive)
    }

    pub fn contains[T: Ord[T]](&self, value: &T) -> Bool {
        value >= self.start and self.checkEnd(value)
    }

    pub fn intoIterator[T: Clone[T]](self) -> RangeIterator[T] {
        RangeIterator.new(self)
    }

    fn checkEnd[T: Ord[T]](&self, value: &T) -> Bool {
        if self.inclusive {
            value <= self.end
        } else {
            value < self.end
        }
    }
}

pub struct RangeIterator[T] {
    range: Range[T],
    current: T,

    pub fn new[T: Clone[T]](range: Range[T]) -> RangeIterator[T] {
        RangeIterator(range, range.start.clone())
    }
}

pub instance[T: Clone[T]] IntoIteratorRange IntoIterator[Range[T]] {
    type Item = T
    type Iter = RangeIterator[T]

    fn intoIterator(self) -> RangeIterator[T] {
        RangeIterator.new(self)
    }
}

pub instance[T: Ord[T], Step[T]] IteratorRangeIterator Iterator[RangeIterator[T]] {
    type Item = T

    fn next(mut self) -> (Self, Option[T]) {
        if self.range.checkEnd(self.current) {
            let nextValue = self.current.step();
            let current = self.current;
            self.current = nextValue;
            (self, Some(current))
        } else {
            (self, None)
        }
    }
}

pub trait Step[T] {
    fn step(&self) -> T
}

pub instance Step[Int] {
    fn step(&self) -> Int {
        self + 1
    }
}

pub instance StepI32 Step[I32] {
    fn step(&self) -> I32 {
        self + 1.toI32()
    }
}

pub instance Step[U64] {
    fn step(&self) -> U64 {
        self + 1.toU64()
    }
}

pub instance[T: Ord[T]] RangeContain Contain[Range[T], T] {
    fn contains(&self, item: &T) -> Bool {
        self.contains(item)
    }
}

}
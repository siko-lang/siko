module Libc.String {

import NativePtr

pub fn memcpy(dest: void*, src: void*, n: U64) -> void* = extern "C" ("string.h")

pub fn memmove(dest: void*, src: void*, n: U64) -> void* = extern "C" ("string.h")

pub fn memcmp(s1: void*, s2: void*, n: U64) -> I32 = extern "C" ("string.h")

@derive(Clone)
pub struct CString {
    data: Vec[U8]

    pub fn fromString(s: String) -> CString {
        let mut bytes = s.toVecU8();
        bytes.push(0.toU8());
        CString(data: bytes)
    }

    @unsafe
    pub fn asPtr(&self) -> *U8 {
        self.data.asPtr()
    }
}

pub instance Show[CString] {
    fn show(&self) -> String {
        let mut data = self.data.clone();
        data.remove(data.len() - 1);
        String.fromVecU8(data)
    }
}

@unsafe
pub fn fromCString(ptr: *U8) -> String {
    if ptr.isNull() {
        return "".toString();
    }
    let mut len = strlen(ptr);
    let mut bytes = Vec.new(len.toInt());
    for i in 0..len.toInt() {
        let byte = *NativePtr.offset(ptr, i.toU64());
        bytes.push(byte);
    }
    String.fromVecU8(bytes)
}

@unsafe
pub fn strlen(s: *U8) -> U64 {
    if s.isNull() {
        return 0.toU64();
    }
    let mut len = 0.toU64();
    loop {
        let byte = *NativePtr.offset(s, len);
        if byte == 0.toU8() {
            break;
        }
        len += 1.toU64();
    }
    len
}

}

module Libc.FileDescriptor {

import Libc.Unistd
import IO.Error
import IO.Buffer
import IO.Reader
import IO.Writer
import Arch.Errno

pub struct FileDescriptor {
    fd: I32,

    pub fn new(fd: I32) -> FileDescriptor {
        FileDescriptor(fd)
    }

    pub fn getFd(&self) -> I32 {
        self.fd
    }

    @safe
    pub fn close(&self) -> Result[(), Error] {
        let result = Libc.Unistd.close(self.fd);
        if result < 0.toI32() {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        Ok(())
    }
}

instance Reader[FileDescriptor] {
    @safe
    fn read(&self, buffer: &WriteBuffer) -> Result[Int, Error] {
        let bytesRead = Libc.Unistd.read(self.fd, buffer.data.asPtr(), buffer.data.len());
        if bytesRead < 0 {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        Ok(bytesRead)
    }
}

instance Writer[FileDescriptor] {
    @safe
    fn write(&self, buffer: &ReadBuffer) -> Result[Int, Error] {
        let bytesWritten = Libc.Unistd.write(self.fd, buffer.data.asPtr(), buffer.data.len());
        if bytesWritten < 0 {
            let err = getErrno();
            return Err(Error.new(err.toInt()));
        }
        Ok(bytesWritten)
    }
}

pub fn getStdInt() -> FileDescriptor {
    FileDescriptor(0.toI32())
}

pub fn getStdOut() -> FileDescriptor {
    FileDescriptor(1.toI32())
}

pub fn getStdErr() -> FileDescriptor {
    FileDescriptor(2.toI32())
}

instance Drop[FileDescriptor] {
    fn drop(self) -> Self {
        self.close();
        self
    }
}

}

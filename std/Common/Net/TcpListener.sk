module Net.TcpListener {

import Libc.FileDescriptor
import Libc.Socket
import Libc.String
import Libc.Unistd
import IO.Error
import IO.Buffer
import IO.Reader
import IO.Writer
import Net.TcpStream
import NativePtr
import Net.SocketUtils
import Arch.SockaddrIn
import Arch.Errno

pub struct TcpListener {
    sock: FileDescriptor,

    @safe
    pub fn bind(addr: &String) -> Result[TcpListener, Error] {
        let (ip, port) = try splitHostPort(addr);
        let sock = try createSocket(AF_INET, SOCK_STREAM);
        let sockAddrIn = SockaddrIn.new(AF_INET, port, 0.toU32());
        try parseAddress(ip, AF_INET, sockAddrIn.addrPtr());
        try bindSocket(sock, sockAddrIn);
        Ok(TcpListener(sock: FileDescriptor.new(sock)))
    }

    @safe
    fn listen(&self, backlog: Int) -> Result[(), Error] {
        let res = Libc.Socket.listen(self.sock.fd, backlog.toI32());
        if res < 0.toI32() {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        Ok(())
    }

    @safe
    fn accept(&self) -> Result[TcpStream, Error] {
        let clientSock = Libc.Socket.accept(self.sock.fd, null(), null());
        if clientSock < 0.toI32() {
            let err = Arch.Errno.getErrnoCode();
            return Err(Error.new(err));
        }
        Ok(TcpStream(sock: FileDescriptor.new(clientSock)))
    }
}

}
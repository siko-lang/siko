module Net.SocketUtils {

import IO.Error
import Libc.Errno
import Libc.Socket
import Int.Util
import Libc.String
import Arch.SockaddrIn

let INADDR_ANY : U32 = 0.toU32();

@unsafe
pub fn createSocket(domain: Domain, ty: SockType) -> Result[I32, Error] {
    let sock = Libc.Socket.socket(domain.code(), ty.code(), 0.toI32());
    if sock < 0.toI32() {
        let err = getErrno();
        println("Err ${err.toInt()}");
        return Err(Error.new(err.toInt()));
    }
    Ok(sock)
}

@unsafe
pub fn connectSocket(sock: I32, sockAddrIn: &SockaddrIn) -> Result[(), Error] {
    let res = Libc.Socket.connect(sock, sockAddrIn.asPtr(), sockAddrIn.len());
    if res < 0.toI32() {
        let err = getErrno();
        return Err(Error.new(err.toInt()));
    }
    Ok(())
}

@unsafe
pub fn bindSocket(sock: I32, sockAddrIn: &SockaddrIn) -> Result[(), Error] {
    let res = Libc.Socket.bind(sock, sockAddrIn.asPtr(), sockAddrIn.len());
    if res < 0.toI32() {
        let err = getErrno();
        return Err(Error.new(err.toInt()));
    }
    Ok(())
}

@unsafe
pub fn parseAddress(addr: Option[String], domain: Domain, mut inAddr: *Libc.Socket.InAddr) -> Result[(), Error] {
    match addr {
        None -> {
            inAddr.s_addr = INADDR_ANY;
            return Ok(());
        }
        Some(addr) -> {
            let addrCStr = CString.fromString(addr);
            let res = inet_pton(domain.code(), addrCStr.asPtr(), inAddr);
            if res <= 0.toI32() {
                let err = getErrno();
                return Err(Error.new(err.toInt()));
            }
        }
    };
    Ok(())
}

pub fn splitHostPort(addr: &String) -> Result[(Option[String], U16), Error] {
    let mut parts = addr.split(':');
    if parts.len() == 1 {
        let portPart = parts.remove(0);
        let port = parseNum(portPart).unwrap();
        return Ok((None, port.toU16()));
    }
    let ipPart = parts.remove(0);
    let portPart = parts.remove(0);
    let port = parseNum(portPart).unwrap();
    Ok((Some(ipPart), port.toU16()))
}

}
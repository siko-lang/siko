module NativePtr {

pub fn eq[T](a: *T, b: *T) -> Bool = extern

pub fn null[T]() -> *T = extern

pub fn isNull[T](addr: *T) -> Bool = extern

pub fn allocateArray[T](count: Int) -> *T = extern

pub fn allocate[T]() -> *T {
    allocateArray(1)
}

pub fn deallocate[T](addr: *T) = extern

pub fn memcpy[T](dest: *T, src: *T, count: Int) = extern

pub fn memmove[T](dest: *T, src: *T, count: Int) = extern

pub fn memcmp[T](dest: *T, src: *T, count: Int) -> Int = extern

pub fn offset[T](base: *T, count: Int) -> *T = extern

pub fn store[T](addr: *T, item: T) = extern

pub fn toRef[T](addr: *T) -> &T = extern

pub fn load[T](addr: *T) -> T = extern

pub fn printPtr[T](addr: *T) = extern

pub fn clone[T](addr: &*T) -> *T = extern

pub fn toU64[T](addr: &*T) -> U64 = extern

pub fn show[T](addr: &*T) -> String {
    let value = toU64(addr);
    value.toHex()
}

instance[T] Show[*T] {
    fn show(addr: &*T) -> String {
        show(addr)
    }
}

}
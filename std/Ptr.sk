module NativePtr {

import Libc

pub fn eq[T](a: *T, b: *T) -> Bool {
    toU64(a) == toU64(b)
}

pub fn null[T]() -> *T {
    transmute(0)
}

pub fn isNull[T](addr: *T) -> Bool {
    toU64(addr) == 0.toU64()
}

pub fn allocateArray[T](count: U64) -> *T {
    let p: *T = null();
    Libc.malloc(count * sizeOf(p))
}

pub fn allocate[T]() -> *T {
    allocateArray(1.toU64())
}

pub fn deallocate[T](addr: *T) {
    Libc.free(addr);
}

pub fn sizeOf[T](addr: *T) -> U64 = extern

pub fn transmute[T, U](v: T) -> U = extern

pub fn cast[T, U](addr: *T) -> *U = extern

pub fn memcpy[T](dest: *T, src: *T, count: U64) {
    Libc.memcpy(dest, src, count * sizeOf(src));
}

pub fn memmove[T](dest: *T, src: *T, count: U64) {
    Libc.memmove(dest, src, count * sizeOf(src));
}

pub fn memcmp[T](dest: *T, src: *T, count: U64) -> Int {
    Libc.memcmp(dest, src, count * sizeOf(src)).toInt()
}

pub fn offset[T](base: *T, count: U64) -> *T {
    let size = sizeOf(base);
    let v: U64 = toU64(base) + (count * size);
    transmute(v)
}

pub fn toRef[T](addr: *T) -> &T {
    let v: &T = transmute(addr);
    v
}

pub fn toPtr[T](addr: &T) -> *T {
    let v: *T = transmute(addr);
    v
}

pub fn clone[T](addr: &*T) -> *T {
    *toPtr(addr)
}

pub fn toU64[T](addr: &*T) -> U64 {
    transmute(clone(addr))
}

pub fn show[T](addr: &*T) -> String {
    let value = toU64(addr);
    value.toHex()
}

pub instance[T] ShowPtr Show[*T] {
    fn show(addr: &*T) -> String {
        show(addr)
    }
    fn toString(addr: &*T) -> String {
        show(addr)
    }
}

pub instance[T] PartialEqPtr PartialEq[*T] {
    fn eq(a: &*T, b: &*T) -> Bool {
        NativePtr.eq(a, b)
    }
    fn ne(a: &*T, b: &*T) -> Bool {
        !NativePtr.eq(a, b)
    }
}

pub instance[T] PtrClone Clone[*T] {
    fn clone(addr: &*T) -> *T {
        NativePtr.clone(addr)
    }
}

pub instance[T] PtrCopy Copy[*T]

}

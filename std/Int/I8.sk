module I8 {

import NativePtr
import Convert
import Std.Ops

@builtin
pub struct I8 {
    pub fn add(self, other: I8) -> I8 = extern

    pub fn sub(self, other: I8) -> I8 = extern

    pub fn mul(self, other: I8) -> I8 = extern

    pub fn div(self, other: I8) -> I8 = extern

    pub fn eq(&self, other: &I8) -> Bool = extern

    pub fn lessThan(&self, other: &I8) -> Bool = extern

    pub fn clone(&self) -> I8 {
        *toPtr(self)
    }

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }
}

pub instance AddI8 Add[I8, I8] {
    type Output = I8
    fn add(self, other: I8) -> I8 {
        self.add(other)
    }
}

pub instance SubI8 Sub[I8] {
    fn sub(self, other: I8) -> I8 {
        self.sub(other)
    }
}

pub instance MulI8 Mul[I8, I8] {
    fn mul(self, other: I8) -> I8 {
        self.mul(other)
    }
}

pub instance DivI8 Div[I8, I8] {
    fn div(self, other: I8) -> I8 {
        self.div(other)
    }
}

pub instance PartialEqI8 PartialEq[I8] {
    fn eq(&self, other: &I8) -> Bool {
        self.eq(other)
    }
}

pub instance EqI8 Eq[I8]

pub instance PartialOrdI8 PartialOrd[I8] {
    fn partialCmp(&self, other: &I8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdI8 Ord[I8] {
    fn cmp(&self, other: &I8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneI8 Clone[I8] {
    fn clone(&self) -> I8 {
        self.clone()
    }
}

pub instance CopyI8 Copy[I8]

pub instance IntoI8Int Into[I8, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

}
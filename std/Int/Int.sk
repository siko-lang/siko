module Int {

import Convert
import NativePtr
import Std.Ops

@builtin
pub struct Int {
    pub fn add(self, other: Int) -> Int = extern

    pub fn sub(self, other: Int) -> Int = extern

    pub fn mul(self, other: Int) -> Int = extern

    pub fn div(self, other: Int) -> Int = extern

    pub fn mod(self, other: Int) -> Int = extern

    pub fn eq(&self, other: &Int) -> Bool = extern

    pub fn lessThan(&self, other: &Int) -> Bool = extern

    @safe
    pub fn toU8(&self) -> U8 {
        transmute(self.clone())
    }

    @safe
    pub fn toI8(&self) -> I8 {
        transmute(self.clone())
    }

    @safe
    pub fn toU32(&self) -> U32 {
        transmute(self.clone())
    }

    @safe
    pub fn toU64(&self) -> U64 {
        transmute(self.clone())
    }

    @safe
    pub fn toI64(&self) -> I64 {
        transmute(self.clone())
    }

    @safe
    pub fn toI32(&self) -> I32 {
        transmute(self.clone())
    }

    @safe
    pub fn clone(&self) -> Int {
        *toPtr(self)
    }
}

pub instance AddInt Add[Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

pub instance AddIntRef Add[Int, &Int] {
    type Output = Int
    fn add(self, other: &Int) -> Int {
        self.add(other.clone())
    }
}

pub instance SubInt Sub[Int, Int] {
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

pub instance MulInt Mul[Int, Int] {
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

pub instance DivInt Div[Int, Int] {
    fn div(self, other: Int) -> Int {
        self.div(other)
    }
}

pub instance PartialEqInt PartialEq[Int] {
    fn eq(&self, other: &Int) -> Bool {
        self.eq(other)
    }
}

pub instance EqInt Eq[Int]

pub instance PartialOrdInt PartialOrd[Int] {
    fn partialCmp(&self, other: &Int) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdInt Ord[Int] {
    fn cmp(&self, other: &Int) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneInt Clone[Int] {
    fn clone(&self) -> Int {
        self.clone()
    }
}

pub instance CopyInt Copy[Int]

pub instance NegInt Neg[Int] {
    fn negative(self) -> Int {
        0 - self
    }
}

pub instance ShowInt Show[Int] {
    fn show(&self) -> String {
        showNum(self)
    }
}

pub instance ModInt Mod[Int] {
    fn mod(&self, other: &Int) -> Int {
        self.mod(other)
    }
}

pub instance IntoIntInt Into[Int, Int] {
    fn into(self) -> Int {
        self.clone()
    }
}

pub instance FromIntInt From[Int, Int] {
    fn from(s: Int) -> Int {
        s
    }
}

pub trait Mod[T] {
    fn mod(&self, other: &T) -> T
}

pub fn showNum[T: Clone[T], Copy[T], PartialEq[T],
              PartialOrd[T], Neg[T],
              Mod[T], From[Int, T], Into[T, Int],
              Div[T, T], Add[T, T, Output=T]](num: &T) -> String {
    // FIXME: fix constants
    let zero: T = from(0);
    let ten: T = from(10);
    let offset: T = from(48);

    let mut n = num.clone();
    if n == zero {
        return "0".toString();
    }

    let mut isNegative = False;

    if n < zero {
        isNegative = True;
        n = -n;
    }

    let mut digits: Vec[U8] = Vec.new();

    while n > zero {
        let base: T = ten.clone();
        let value: T = n.mod(base) + offset.clone();
        let digit: Int = value.into();
        digits.push(digit.toU8());
        n /= base;
    }

    if isNegative {
        digits.push('-');
    }

    digits.reverse();

    String.fromU8(digits)
}

@test
fn testAdd() {
    let a: Int = 10;
    let b: Int = 20;
    let c = a + b;
    assert(c == 30);
}


@test
fn testSub() {
    let a: Int = 10;
    let b: Int = 20;
    let c = b - a;
    assert(c == 10);
}


}
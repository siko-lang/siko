module U16 {

import Convert
import NativePtr
import Std.Ops

@builtin
pub struct U16 {
    pub fn add(self, other: U16) -> U16 = extern

    pub fn sub(self, other: U16) -> U16 = extern

    pub fn mul(self, other: U16) -> U16 = extern

    pub fn div(self, other: U16) -> U16 = extern

    pub fn eq(&self, other: &U16) -> Bool = extern

    pub fn lessThan(&self, other: &U16) -> Bool = extern

    @safe
    pub fn clone(&self) -> U16 {
        *toPtr(self)
    }
}

pub instance AddU16 Add[U16, U16] {
    type Output = U16
    fn add(self, other: U16) -> U16 {
        self.add(other)
    }
}

pub instance AddU16 Add[U16, &U16] {
    type Output = U16
    fn add(self, other: &U16) -> U16 {
        self.add(other)
    }
}

pub instance SubU16 Sub[U16] {
    fn sub(self, other: U16) -> U16 {
        self.sub(other)
    }
}

pub instance MulU16 Mul[U16, U16] {
    fn mul(self, other: U16) -> U16 {
        self.mul(other)
    }
}

pub instance DivU16 Div[U16, U16] {
    fn div(self, other: U16) -> U16 {
        self.div(other)
    }
}

pub instance PartialEqU16 PartialEq[U16] {
    fn eq(&self, other: &U16) -> Bool {
        self.eq(other)
    }
}

pub instance EqU16 Eq[U16]

pub instance PartialOrdU16 PartialOrd[U16] {
    fn partialCmp(&self, other: &U16) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdU16 Ord[U16] {
    fn cmp(&self, other: &U16) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneU16 Clone[U16] {
    fn clone(&self) -> U16 {
        self.clone()
    }
}

pub instance CopyU16 Copy[U16]

}
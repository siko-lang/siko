module Int {

import Convert
import NativePtr
import Std.Ops

pub extern struct Int {
    pub fn add(self, other: Int) -> Int = extern

    pub fn sub(self, other: Int) -> Int = extern

    pub fn mul(self, other: Int) -> Int = extern

    pub fn div(self, other: Int) -> Int = extern

    pub fn mod(self, other: Int) -> Int = extern

    pub fn toU8(&self) -> U8 {
        transmute(self.clone())
    }

    pub fn toI8(&self) -> I8 {
        transmute(self.clone())
    }

    pub fn toU32(&self) -> U32 {
        transmute(self.clone())
    }

    pub fn toU64(&self) -> U64 {
        transmute(self.clone())
    }

    pub fn toI32(&self) -> I32 {
        transmute(self.clone())
    }

    pub fn eq(&self, other: &Int) -> Bool = extern

    pub fn lessThan(&self, other: &Int) -> Bool = extern

    pub fn clone(&self) -> Int {
        *toPtr(self)
    }
}

pub impl AddInt Add[Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

pub impl AddIntRef Add[Int, &Int] {
    type Output = Int
    fn add(self, other: &Int) -> Int {
        self.add(other.clone())
    }
}

pub impl SubInt Sub[Int, Int] {
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

pub impl MulInt Mul[Int, Int] {
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

pub impl DivInt Div[Int, Int] {
    fn div(self, other: Int) -> Int {
        self.div(other)
    }
}

pub impl PartialEqInt PartialEq[Int] {
    fn eq(&self, other: &Int) -> Bool {
        self.eq(other)
    }
}

pub impl EqInt Eq[Int]

pub impl PartialOrdInt PartialOrd[Int] {
    fn partialCmp(&self, other: &Int) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdInt Ord[Int] {
    fn cmp(&self, other: &Int) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[Int] {
    fn clone(&self) -> Int {
        self.clone()
    }
}

instance Copy[Int]

pub impl NegInt Neg[Int] {
    fn negative(self) -> Int {
        0 - self
    }
}

pub impl ShowInt Show[Int] {
    fn show(&self) -> String {
        //showNum(self)
        showInt(self)
    }
}

instance Mod[Int] {
    fn mod(&self, other: &Int) -> Int {
        self.mod(other)
    }
}

instance Into[Int, Int] {
    fn into(self) -> Int {
        self.clone()
    }
}

instance From[Int, Int] {
    fn from(s: Int) -> Int {
        s
    }
}

trait Mod[T] {
    fn mod(&self, other: &T) -> T
}

fn showInt(num: &Int) -> String {
    let mut n = num.clone();
    if n == 0 {
        return "0".toString();
    }

    let mut isNegative = False;

    if n < 0 {
        isNegative = True;
        n = -n;
    }

    let mut digits: Vec[U8] = Vec.new();

    while n > 0 {
        let base = 10;
        let value = n.mod(base) + '0'.toInt();
        let digit: Int = value.into();
        digits.push(digit.toU8());
        n /= base;
    }

    if isNegative {
        digits.push('-');
    }

    digits.reverse();

    String.fromU8(digits)
}

// fn showNum[T: Clone[T], Copy[T], PartialEq[T],
//               PartialOrd[T], Neg[T],
//               Mod[T], From[Int, T], Into[T, Int],
//               Div[T], Add[T, T, Output=T]](num: &T) -> String {
//     // FIXME: fix constants
//     let zero: T = from(0);
//     let ten: T = from(10);
//     let offset: T = from(48);

//     let mut n = num.clone();
//     if n == zero {
//         return "0".toString();
//     }

//     let mut isNegative = False;

//     if n < zero {
//         isNegative = True;
//         n = -n;
//     }

//     let mut digits: Vec[U8] = Vec.new();

//     while n > zero {
//         let base: T = ten.clone();
//         let value: T = n.mod(base) + offset.clone();
//         let digit: Int = value.into();
//         digits.push(digit.toU8());
//         n /= base;
//     }

//     if isNegative {
//         digits.push('-');
//     }

//     digits.reverse();

//     String.fromU8(digits)
// }

pub extern struct U8 {
    pub fn add(self, other: U8) -> U8 = extern

    pub fn sub(self, other: U8) -> U8 = extern

    pub fn mul(self, other: U8) -> U8 = extern

    pub fn div(self, other: U8) -> U8 = extern

    pub fn eq(&self, other: &U8) -> Bool = extern

    pub fn lessThan(&self, other: &U8) -> Bool = extern

    pub fn clone(&self) -> U8 {
        *toPtr(self)
    }

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }
}

pub impl AddU8 Add[U8, U8] {
    type Output = U8
    fn add(self, other: U8) -> U8 {
        self.add(other)
    }
}

pub impl SubU8 Sub[U8] {
    fn sub(self, other: U8) -> U8 {
        self.sub(other)
    }
}

pub impl MulU8 Mul[U8, U8] {
    fn mul(self, other: U8) -> U8 {
        self.mul(other)
    }
}

pub impl DivU8 Div[U8, U8] {
    fn div(self, other: U8) -> U8 {
        self.div(other)
    }
}

pub impl PartialEqU8 PartialEq[U8] {
    fn eq(&self, other: &U8) -> Bool {
        self.eq(other)
    }
}

pub impl EqU8 Eq[U8]

pub impl PartialOrdU8 PartialOrd[U8] {
    fn partialCmp(&self, other: &U8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdU8 Ord[U8] {
    fn cmp(&self, other: &U8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U8] {
    fn clone(&self) -> U8 {
        self.clone()
    }
}

instance Copy[U8]

instance Into[U8, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct I8 {
    pub fn add(self, other: I8) -> I8 = extern

    pub fn sub(self, other: I8) -> I8 = extern

    pub fn mul(self, other: I8) -> I8 = extern

    pub fn div(self, other: I8) -> I8 = extern

    pub fn eq(&self, other: &I8) -> Bool = extern

    pub fn lessThan(&self, other: &I8) -> Bool = extern

    pub fn clone(&self) -> I8 {
        *toPtr(self)
    }
}

pub impl AddI8 Add[I8, I8] {
    type Output = I8
    fn add(self, other: I8) -> I8 {
        self.add(other)
    }
}

pub impl SubI8 Sub[I8] {
    fn sub(self, other: I8) -> I8 {
        self.sub(other)
    }
}

pub impl MulI8 Mul[I8, I8] {
    fn mul(self, other: I8) -> I8 {
        self.mul(other)
    }
}

pub impl DivI8 Div[I8, I8] {
    fn div(self, other: I8) -> I8 {
        self.div(other)
    }
}

pub impl PartialEqI8 PartialEq[I8] {
    fn eq(&self, other: &I8) -> Bool {
        self.eq(other)
    }
}

pub impl EqI8 Eq[I8]

pub impl PartialOrdI8 PartialOrd[I8] {
    fn partialCmp(&self, other: &I8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdI8 Ord[I8] {
    fn cmp(&self, other: &I8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[I8] {
    fn clone(&self) -> I8 {
        self.clone()
    }
}

instance Copy[I8]

pub extern struct I32 {
    pub fn add(self, other: I32) -> I32 = extern

    pub fn sub(self, other: I32) -> I32 = extern

    pub fn mul(self, other: I32) -> I32 = extern

    pub fn div(self, other: I32) -> I32 = extern

    pub fn eq(&self, other: &I32) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &I32) -> Bool = extern

    pub fn clone(&self) -> I32 {
        *toPtr(self)
    }
}

pub impl AddI32 Add[I32, I32] {
    type Output = I32
    fn add(self, other: I32) -> I32 {
        self.add(other)
    }
}

pub impl SubI32 Sub[I32] {
    fn sub(self, other: I32) -> I32 {
        self.sub(other)
    }
}

pub impl MulI32 Mul[I32, I32] {
    fn mul(self, other: I32) -> I32 {
        self.mul(other)
    }
}

pub impl DivI32 Div[I32, I32] {
    fn div(self, other: I32) -> I32 {
        self.div(other)
    }
}

pub impl PartialEqI32 PartialEq[I32] {
    fn eq(&self, other: &I32) -> Bool {
        self.eq(other)
    }
}

pub impl EqI32 Eq[I32]

pub impl PartialOrdI32 PartialOrd[I32] {
    fn partialCmp(&self, other: &I32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdI32 Ord[I32] {
    fn cmp(&self, other: &I32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[I32] {
    fn clone(&self) -> I32 {
        self.clone()
    }
}

instance Copy[I32]

instance Into[I32, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct U32 {
    pub fn add(self, other: U32) -> U32 = extern

    pub fn sub(self, other: U32) -> U32 = extern

    pub fn mul(self, other: U32) -> U32 = extern

    pub fn div(self, other: U32) -> U32 = extern

    pub fn eq(&self, other: &U32) -> Bool = extern

    pub fn lessThan(&self, other: &U32) -> Bool = extern

    pub fn clone(&self) -> U32 {
        *toPtr(self)
    }
}

pub impl AddU32 Add[U32, U32] {
    type Output = U32
    fn add(self, other: U32) -> U32 {
        self.add(other)
    }
}

pub impl AddU32 Add[U32, &U32] {
    type Output = U32
    fn add(self, other: &U32) -> U32 {
        self.add(other)
    }
}

pub impl SubU32 Sub[U32] {
    fn sub(self, other: U32) -> U32 {
        self.sub(other)
    }
}

pub impl MulU32 Mul[U32, U32] {
    fn mul(self, other: U32) -> U32 {
        self.mul(other)
    }
}

pub impl DivU32 Div[U32, U32] {
    fn div(self, other: U32) -> U32 {
        self.div(other)
    }
}

pub impl PartialEqU32 PartialEq[U32] {
    fn eq(&self, other: &U32) -> Bool {
        self.eq(other)
    }
}

pub impl EqU32 Eq[U32]

pub impl PartialOrdU32 PartialOrd[U32] {
    fn partialCmp(&self, other: &U32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdU32 Ord[U32] {
    fn cmp(&self, other: &U32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U32] {
    fn clone(&self) -> U32 {
        self.clone()
    }
}

instance Copy[U32]

pub extern struct U64 {
    pub fn add(self, other: U64) -> U64 = extern

    pub fn sub(self, other: U64) -> U64 = extern

    pub fn mul(self, other: U64) -> U64 = extern

    pub fn div(self, other: U64) -> U64 = extern

    pub fn mod(self, other: U64) -> U64 = extern

    pub fn eq(&self, other: &U64) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &U64) -> Bool = extern

    pub fn clone(&self) -> U64 {
        *toPtr(self)
    }

    pub fn toHex(&self) -> String {
        let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        let mut hex = String.new();
        let mut n = self.clone();
        let zero = 0.toU64();
        let sixteen = 16.toU64();

        if n == zero {
            return "0x0";
        }

        while n > zero {
            let rem = n.mod(sixteen);
            hex.pushChar(digits.get(rem.toInt()));
            n /= sixteen.clone();
        }
        hex += "x0";
        hex.reverse();
        hex
    }
}

pub impl AddU64 Add[U64, U64] {
    type Output = U64
    fn add(self, other: U64) -> U64 {
        self.add(other)
    }
}

pub impl SubU64 Sub[U64, U64] {
    fn sub(self, other: U64) -> U64 {
        self.sub(other)
    }
}

pub impl MulU64 Mul[U64, U64] {
    fn mul(self, other: U64) -> U64 {
        self.mul(other)
    }
}

pub impl DivU64 Div[U64, U64] {
    fn div(self, other: U64) -> U64 {
        self.div(other)
    }
}

pub impl PartialEqU64 PartialEq[U64] {
    fn eq(&self, other: &U64) -> Bool {
        self.eq(other)
    }
}

pub impl EqU64 Eq[U64]

pub impl PartialOrdU64 PartialOrd[U64] {
    fn partialCmp(&self, other: &U64) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub impl OrdU64 Ord[U64] {
    fn cmp(&self, other: &U64) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U64] {
    fn clone(&self) -> U64 {
        self.clone()
    }
}

instance Copy[U64]

pub impl ShowU64 Show[U64] {
    fn show(&self) -> String {
        //showNum(self)
        showInt(self.toInt())
    }
}

pub impl NegU64 Neg[U64] {
    fn negative(self) -> U64 {
        self
    }
}

instance Mod[U64] {
    fn mod(&self, other: &U64) -> U64 {
        self.mod(other)
    }
}

instance From[Int, U64] {
    fn from(v: Int) -> U64 {
        v.toU64()
    }
}

instance Into[U64, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

}
module Int {

import Convert
import NativePtr
import Std.Ops

pub extern struct Int {
    pub fn add(self, other: Int) -> Int = extern

    pub fn sub(self, other: Int) -> Int = extern

    pub fn mul(self, other: Int) -> Int = extern

    pub fn div(self, other: Int) -> Int = extern

    pub fn mod(self, other: Int) -> Int = extern

    pub fn toU8(&self) -> U8 {
        transmute(self.clone())
    }

    pub fn toI8(&self) -> I8 {
        transmute(self.clone())
    }

    pub fn toU32(&self) -> U32 {
        transmute(self.clone())
    }

    pub fn toU64(&self) -> U64 {
        transmute(self.clone())
    }

    pub fn toI32(&self) -> I32 {
        transmute(self.clone())
    }

    pub fn eq(&self, other: &Int) -> Bool = extern

    pub fn lessThan(&self, other: &Int) -> Bool = extern

    pub fn clone(&self) -> Int {
        *toPtr(self)
    }
}

instance Add[Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

instance Sub[Int] {
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

instance Mul[Int] {
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

instance Div[Int] {
    fn div(self, other: Int) -> Int {
        self.div(other)
    }
}

instance PartialEq[Int] {
    fn eq(&self, other: &Int) -> Bool {
        self.eq(other)
    }
}

instance Eq[Int]

instance PartialOrd[Int] {
    fn partialCmp(&self, other: &Int) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[Int] {
    fn cmp(&self, other: &Int) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[Int] {
    fn clone(&self) -> Int {
        self.clone()
    }
}

instance Copy[Int]

instance Neg[Int] {
    fn negative(self) -> Int {
        0 - self
    }
}

instance Show[Int] {
    fn show(&self) -> String {
        showNum(self)
    }
}

instance Mod[Int] {
    fn mod(&self, other: &Int) -> Int {
        self.mod(other)
    }
}

instance Into[Int, Int] {
    fn into(self) -> Int {
        self.clone()
    }
}

instance From[Int, Int] {
    fn from(s: Int) -> Int {
        s
    }
}

trait Mod[T] {
    fn mod(&self, other: &T) -> T
}

fn showNum[T: Clone[T], Copy[T], PartialEq[T],
              PartialOrd[T], Neg[T],
              Mod[T], From[Int, T], Into[T, Int],
              Div[T], Add[T, T, Output=T]](num: &T) -> String {
    // FIXME: fix constants
    let zero: T = from(0);
    let ten: T = from(10);
    let offset: T = from(48);

    let mut n = num.clone();
    if n == zero {
        return "0".toString();
    }

    let mut isNegative = False;

    if n < zero {
        isNegative = True;
        n = -n;
    }

    let mut digits: Vec[U8] = Vec.new();

    while n > zero {
        let base: T = ten.clone();
        let value: T = n.mod(base) + offset.clone();
        let digit: Int = value.into();
        digits.push(digit.toU8());
        n /= base;
    }

    if isNegative {
        digits.push('-');
    }

    digits.reverse();

    String.fromU8(digits)
}

pub extern struct U8 {
    pub fn add(self, other: U8) -> U8 = extern

    pub fn sub(self, other: U8) -> U8 = extern

    pub fn mul(self, other: U8) -> U8 = extern

    pub fn div(self, other: U8) -> U8 = extern

    pub fn eq(&self, other: &U8) -> Bool = extern

    pub fn lessThan(&self, other: &U8) -> Bool = extern

    pub fn clone(&self) -> U8 {
        *toPtr(self)
    }

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }
}

instance Add[U8, U8] {
    type Output = U8
    fn add(self, other: U8) -> U8 {
        self.add(other)
    }
}

instance Sub[U8] {
    fn sub(self, other: U8) -> U8 {
        self.sub(other)
    }
}

instance Mul[U8] {
    fn mul(self, other: U8) -> U8 {
        self.mul(other)
    }
}

instance Div[U8] {
    fn div(self, other: U8) -> U8 {
        self.div(other)
    }
}

instance PartialEq[U8] {
    fn eq(&self, other: &U8) -> Bool {
        self.eq(other)
    }
}

instance Eq[U8]

instance PartialOrd[U8] {
    fn partialCmp(&self, other: &U8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[U8] {
    fn cmp(&self, other: &U8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U8] {
    fn clone(&self) -> U8 {
        self.clone()
    }
}

instance Copy[U8]

instance Into[U8, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct I8 {
    pub fn add(self, other: I8) -> I8 = extern

    pub fn sub(self, other: I8) -> I8 = extern

    pub fn mul(self, other: I8) -> I8 = extern

    pub fn div(self, other: I8) -> I8 = extern

    pub fn eq(&self, other: &I8) -> Bool = extern

    pub fn lessThan(&self, other: &I8) -> Bool = extern

    pub fn clone(&self) -> I8 {
        *toPtr(self)
    }
}

instance Add[I8, I8] {
    type Output = I8
    fn add(self, other: I8) -> I8 {
        self.add(other)
    }
}

instance Sub[I8] {
    fn sub(self, other: I8) -> I8 {
        self.sub(other)
    }
}

instance Mul[I8] {
    fn mul(self, other: I8) -> I8 {
        self.mul(other)
    }
}

instance Div[I8] {
    fn div(self, other: I8) -> I8 {
        self.div(other)
    }
}

instance PartialEq[I8] {
    fn eq(&self, other: &I8) -> Bool {
        self.eq(other)
    }
}

instance Eq[I8]

instance PartialOrd[I8] {
    fn partialCmp(&self, other: &I8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[I8] {
    fn cmp(&self, other: &I8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[I8] {
    fn clone(&self) -> I8 {
        self.clone()
    }
}

instance Copy[I8]

pub extern struct I32 {
    pub fn add(self, other: I32) -> I32 = extern

    pub fn sub(self, other: I32) -> I32 = extern

    pub fn mul(self, other: I32) -> I32 = extern

    pub fn div(self, other: I32) -> I32 = extern

    pub fn eq(&self, other: &I32) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &I32) -> Bool = extern

    pub fn clone(&self) -> I32 {
        *toPtr(self)
    }
}

instance Add[I32, I32] {
    type Output = I32
    fn add(self, other: I32) -> I32 {
        self.add(other)
    }
}

instance Sub[I32] {
    fn sub(self, other: I32) -> I32 {
        self.sub(other)
    }
}

instance Mul[I32] {
    fn mul(self, other: I32) -> I32 {
        self.mul(other)
    }
}

instance Div[I32] {
    fn div(self, other: I32) -> I32 {
        self.div(other)
    }
}

instance PartialEq[I32] {
    fn eq(&self, other: &I32) -> Bool {
        self.eq(other)
    }
}

instance Eq[I32]

instance PartialOrd[I32] {
    fn partialCmp(&self, other: &I32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[I32] {
    fn cmp(&self, other: &I32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[I32] {
    fn clone(&self) -> I32 {
        self.clone()
    }
}

instance Copy[I32]

instance Into[I32, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct U32 {
    pub fn add(self, other: U32) -> U32 = extern

    pub fn sub(self, other: U32) -> U32 = extern

    pub fn mul(self, other: U32) -> U32 = extern

    pub fn div(self, other: U32) -> U32 = extern

    pub fn eq(&self, other: &U32) -> Bool = extern

    pub fn lessThan(&self, other: &U32) -> Bool = extern

    pub fn clone(&self) -> U32 {
        *toPtr(self)
    }
}

instance Add[U32, U32] {
    type Output = U32
    fn add(self, other: U32) -> U32 {
        self.add(other)
    }
}

instance Add[U32, &U32] {
    type Output = U32
    fn add(self, other: &U32) -> U32 {
        self.add(other)
    }
}

instance Sub[U32] {
    fn sub(self, other: U32) -> U32 {
        self.sub(other)
    }
}

instance Mul[U32] {
    fn mul(self, other: U32) -> U32 {
        self.mul(other)
    }
}

instance Div[U32] {
    fn div(self, other: U32) -> U32 {
        self.div(other)
    }
}

instance PartialEq[U32] {
    fn eq(&self, other: &U32) -> Bool {
        self.eq(other)
    }
}

instance Eq[U32]

instance PartialOrd[U32] {
    fn partialCmp(&self, other: &U32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[U32] {
    fn cmp(&self, other: &U32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U32] {
    fn clone(&self) -> U32 {
        self.clone()
    }
}

instance Copy[U32]

pub extern struct U64 {
    pub fn add(self, other: U64) -> U64 = extern

    pub fn sub(self, other: U64) -> U64 = extern

    pub fn mul(self, other: U64) -> U64 = extern

    pub fn div(self, other: U64) -> U64 = extern

    pub fn mod(self, other: U64) -> U64 = extern

    pub fn eq(&self, other: &U64) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &U64) -> Bool = extern

    pub fn clone(&self) -> U64 {
        *toPtr(self)
    }

    pub fn toHex(&self) -> String {
        let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        let mut hex = String.new();
        let mut n = self.clone();
        let zero = 0.toU64();
        let sixteen = 16.toU64();

        if n == zero {
            return "0x0";
        }

        while n > zero {
            let rem = n.mod(sixteen);
            hex.pushChar(digits.get(rem.toInt()));
            n /= sixteen.clone();
        }
        hex += "x0";
        hex.reverse();
        hex
    }
}

instance Add[U64, U64] {
    type Output = U64
    fn add(self, other: U64) -> U64 {
        self.add(other)
    }
}

instance Sub[U64] {
    fn sub(self, other: U64) -> U64 {
        self.sub(other)
    }
}

instance Mul[U64] {
    fn mul(self, other: U64) -> U64 {
        self.mul(other)
    }
}

instance Div[U64] {
    fn div(self, other: U64) -> U64 {
        self.div(other)
    }
}

instance PartialEq[U64] {
    fn eq(&self, other: &U64) -> Bool {
        self.eq(other)
    }
}

instance Eq[U64]

instance PartialOrd[U64] {
    fn partialCmp(&self, other: &U64) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

instance Ord[U64] {
    fn cmp(&self, other: &U64) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

instance Clone[U64] {
    fn clone(&self) -> U64 {
        self.clone()
    }
}

instance Copy[U64]

instance Show[U64] {
    fn show(&self) -> String {
        showNum(self)
    }
}

instance Neg[U64] {
    fn negative(self) -> U64 {
        self
    }
}

instance Mod[U64] {
    fn mod(&self, other: &U64) -> U64 {
        self.mod(other)
    }
}

instance From[Int, U64] {
    fn from(v: Int) -> U64 {
        v.toU64()
    }
}

instance Into[U64, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

}
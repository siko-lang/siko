module Int {

import Convert
import NativePtr
import Std.Ops

pub extern struct Int {
    pub fn add(self, other: Int) -> Int = extern

    pub fn sub(self, other: Int) -> Int = extern

    pub fn mul(self, other: Int) -> Int = extern

    pub fn div(self, other: Int) -> Int = extern

    pub fn mod(self, other: Int) -> Int = extern

    pub fn toU8(&self) -> U8 {
        transmute(self.clone())
    }

    pub fn toI8(&self) -> I8 {
        transmute(self.clone())
    }

    pub fn toU32(&self) -> U32 {
        transmute(self.clone())
    }

    pub fn toU64(&self) -> U64 {
        transmute(self.clone())
    }

    pub fn toI32(&self) -> I32 {
        transmute(self.clone())
    }

    pub fn eq(&self, other: &Int) -> Bool = extern

    pub fn lessThan(&self, other: &Int) -> Bool = extern

    pub fn clone(&self) -> Int {
        *toPtr(self)
    }
}

pub instance AddInt Add[Int, Int] {
    type Output = Int
    fn add(self, other: Int) -> Int {
        self.add(other)
    }
}

pub instance AddIntRef Add[Int, &Int] {
    type Output = Int
    fn add(self, other: &Int) -> Int {
        self.add(other.clone())
    }
}

pub instance SubInt Sub[Int, Int] {
    fn sub(self, other: Int) -> Int {
        self.sub(other)
    }
}

pub instance MulInt Mul[Int, Int] {
    fn mul(self, other: Int) -> Int {
        self.mul(other)
    }
}

pub instance DivInt Div[Int, Int] {
    fn div(self, other: Int) -> Int {
        self.div(other)
    }
}

pub instance PartialEqInt PartialEq[Int] {
    fn eq(&self, other: &Int) -> Bool {
        self.eq(other)
    }
}

pub instance EqInt Eq[Int]

pub instance PartialOrdInt PartialOrd[Int] {
    fn partialCmp(&self, other: &Int) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdInt Ord[Int] {
    fn cmp(&self, other: &Int) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneInt Clone[Int] {
    fn clone(&self) -> Int {
        self.clone()
    }
}

pub instance CopyInt Copy[Int]

pub instance NegInt Neg[Int] {
    fn negative(self) -> Int {
        0 - self
    }
}

pub instance ShowInt Show[Int] {
    fn show(&self) -> String {
        //showNum(self)
        showInt(self)
    }
}

pub instance ModInt Mod[Int] {
    fn mod(&self, other: &Int) -> Int {
        self.mod(other)
    }
}

pub instance IntoIntInt Into[Int, Int] {
    fn into(self) -> Int {
        self.clone()
    }
}

pub instance FromIntInt From[Int, Int] {
    fn from(s: Int) -> Int {
        s
    }
}

pub trait Mod[T] {
    fn mod(&self, other: &T) -> T
}

fn showInt(num: &Int) -> String {
    let mut n = num.clone();
    if n == 0 {
        return "0".toString();
    }

    let mut isNegative = False;

    if n < 0 {
        isNegative = True;
        n = -n;
    }

    let mut digits: Vec[U8] = Vec.new();

    while n > 0 {
        let base = 10;
        let value = n.mod(base) + '0'.toInt();
        let digit: Int = value.into();
        digits.push(digit.toU8());
        n /= base;
    }

    if isNegative {
        digits.push('-');
    }

    digits.reverse();

    String.fromU8(digits)
}

// fn showNum[T: Clone[T], Copy[T], PartialEq[T],
//               PartialOrd[T], Neg[T],
//               Mod[T], From[Int, T], Into[T, Int],
//               Div[T], Add[T, T, Output=T]](num: &T) -> String {
//     // FIXME: fix constants
//     let zero: T = from(0);
//     let ten: T = from(10);
//     let offset: T = from(48);

//     let mut n = num.clone();
//     if n == zero {
//         return "0".toString();
//     }

//     let mut isNegative = False;

//     if n < zero {
//         isNegative = True;
//         n = -n;
//     }

//     let mut digits: Vec[U8] = Vec.new();

//     while n > zero {
//         let base: T = ten.clone();
//         let value: T = n.mod(base) + offset.clone();
//         let digit: Int = value.into();
//         digits.push(digit.toU8());
//         n /= base;
//     }

//     if isNegative {
//         digits.push('-');
//     }

//     digits.reverse();

//     String.fromU8(digits)
// }

pub extern struct U8 {
    pub fn add(self, other: U8) -> U8 = extern

    pub fn sub(self, other: U8) -> U8 = extern

    pub fn mul(self, other: U8) -> U8 = extern

    pub fn div(self, other: U8) -> U8 = extern

    pub fn eq(&self, other: &U8) -> Bool = extern

    pub fn lessThan(&self, other: &U8) -> Bool = extern

    pub fn clone(&self) -> U8 {
        *toPtr(self)
    }

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }
}

pub instance AddU8 Add[U8, U8] {
    type Output = U8
    fn add(self, other: U8) -> U8 {
        self.add(other)
    }
}

pub instance SubU8 Sub[U8] {
    fn sub(self, other: U8) -> U8 {
        self.sub(other)
    }
}

pub instance MulU8 Mul[U8, U8] {
    fn mul(self, other: U8) -> U8 {
        self.mul(other)
    }
}

pub instance DivU8 Div[U8, U8] {
    fn div(self, other: U8) -> U8 {
        self.div(other)
    }
}

pub instance PartialEqU8 PartialEq[U8] {
    fn eq(&self, other: &U8) -> Bool {
        self.eq(other)
    }
}

pub instance EqU8 Eq[U8]

pub instance PartialOrdU8 PartialOrd[U8] {
    fn partialCmp(&self, other: &U8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdU8 Ord[U8] {
    fn cmp(&self, other: &U8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneU8 Clone[U8] {
    fn clone(&self) -> U8 {
        self.clone()
    }
}

pub instance CopyU8 Copy[U8]

pub instance IntoU8Int Into[U8, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct I8 {
    pub fn add(self, other: I8) -> I8 = extern

    pub fn sub(self, other: I8) -> I8 = extern

    pub fn mul(self, other: I8) -> I8 = extern

    pub fn div(self, other: I8) -> I8 = extern

    pub fn eq(&self, other: &I8) -> Bool = extern

    pub fn lessThan(&self, other: &I8) -> Bool = extern

    pub fn clone(&self) -> I8 {
        *toPtr(self)
    }
}

pub instance AddI8 Add[I8, I8] {
    type Output = I8
    fn add(self, other: I8) -> I8 {
        self.add(other)
    }
}

pub instance SubI8 Sub[I8] {
    fn sub(self, other: I8) -> I8 {
        self.sub(other)
    }
}

pub instance MulI8 Mul[I8, I8] {
    fn mul(self, other: I8) -> I8 {
        self.mul(other)
    }
}

pub instance DivI8 Div[I8, I8] {
    fn div(self, other: I8) -> I8 {
        self.div(other)
    }
}

pub instance PartialEqI8 PartialEq[I8] {
    fn eq(&self, other: &I8) -> Bool {
        self.eq(other)
    }
}

pub instance EqI8 Eq[I8]

pub instance PartialOrdI8 PartialOrd[I8] {
    fn partialCmp(&self, other: &I8) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdI8 Ord[I8] {
    fn cmp(&self, other: &I8) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneI8 Clone[I8] {
    fn clone(&self) -> I8 {
        self.clone()
    }
}

pub instance CopyI8 Copy[I8]

pub extern struct I32 {
    pub fn add(self, other: I32) -> I32 = extern

    pub fn sub(self, other: I32) -> I32 = extern

    pub fn mul(self, other: I32) -> I32 = extern

    pub fn div(self, other: I32) -> I32 = extern

    pub fn eq(&self, other: &I32) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &I32) -> Bool = extern

    pub fn clone(&self) -> I32 {
        *toPtr(self)
    }
}

pub instance AddI32 Add[I32, I32] {
    type Output = I32
    fn add(self, other: I32) -> I32 {
        self.add(other)
    }
}

pub instance SubI32 Sub[I32] {
    fn sub(self, other: I32) -> I32 {
        self.sub(other)
    }
}

pub instance MulI32 Mul[I32, I32] {
    fn mul(self, other: I32) -> I32 {
        self.mul(other)
    }
}

pub instance DivI32 Div[I32, I32] {
    fn div(self, other: I32) -> I32 {
        self.div(other)
    }
}

pub instance PartialEqI32 PartialEq[I32] {
    fn eq(&self, other: &I32) -> Bool {
        self.eq(other)
    }
}

pub instance EqI32 Eq[I32]

pub instance PartialOrdI32 PartialOrd[I32] {
    fn partialCmp(&self, other: &I32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdI32 Ord[I32] {
    fn cmp(&self, other: &I32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneI32 Clone[I32] {
    fn clone(&self) -> I32 {
        self.clone()
    }
}

pub instance CopyI32 Copy[I32]

pub instance IntoI32Int Into[I32, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

pub extern struct U32 {
    pub fn add(self, other: U32) -> U32 = extern

    pub fn sub(self, other: U32) -> U32 = extern

    pub fn mul(self, other: U32) -> U32 = extern

    pub fn div(self, other: U32) -> U32 = extern

    pub fn eq(&self, other: &U32) -> Bool = extern

    pub fn lessThan(&self, other: &U32) -> Bool = extern

    pub fn clone(&self) -> U32 {
        *toPtr(self)
    }
}

pub instance AddU32 Add[U32, U32] {
    type Output = U32
    fn add(self, other: U32) -> U32 {
        self.add(other)
    }
}

pub instance AddU32 Add[U32, &U32] {
    type Output = U32
    fn add(self, other: &U32) -> U32 {
        self.add(other)
    }
}

pub instance SubU32 Sub[U32] {
    fn sub(self, other: U32) -> U32 {
        self.sub(other)
    }
}

pub instance MulU32 Mul[U32, U32] {
    fn mul(self, other: U32) -> U32 {
        self.mul(other)
    }
}

pub instance DivU32 Div[U32, U32] {
    fn div(self, other: U32) -> U32 {
        self.div(other)
    }
}

pub instance PartialEqU32 PartialEq[U32] {
    fn eq(&self, other: &U32) -> Bool {
        self.eq(other)
    }
}

pub instance EqU32 Eq[U32]

pub instance PartialOrdU32 PartialOrd[U32] {
    fn partialCmp(&self, other: &U32) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdU32 Ord[U32] {
    fn cmp(&self, other: &U32) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneU32 Clone[U32] {
    fn clone(&self) -> U32 {
        self.clone()
    }
}

pub instance CopyU32 Copy[U32]

pub extern struct U64 {
    pub fn add(self, other: U64) -> U64 = extern

    pub fn sub(self, other: U64) -> U64 = extern

    pub fn mul(self, other: U64) -> U64 = extern

    pub fn div(self, other: U64) -> U64 = extern

    pub fn mod(self, other: U64) -> U64 = extern

    pub fn eq(&self, other: &U64) -> Bool = extern

    pub fn toInt(&self) -> Int {
        transmute(self.clone())
    }

    pub fn lessThan(&self, other: &U64) -> Bool = extern

    pub fn clone(&self) -> U64 {
        *toPtr(self)
    }

    pub fn toHex(&self) -> String {
        let digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        let mut hex = String.new();
        let mut n = self.clone();
        let zero = 0.toU64();
        let sixteen = 16.toU64();

        if n == zero {
            return "0x0";
        }

        while n > zero {
            let rem = n.mod(sixteen);
            hex.pushChar(digits.get(rem.toInt()));
            n /= sixteen.clone();
        }
        hex += "x0";
        hex.reverse();
        hex
    }
}

pub instance AddU64 Add[U64, U64] {
    type Output = U64
    fn add(self, other: U64) -> U64 {
        self.add(other)
    }
}

pub instance SubU64 Sub[U64, U64] {
    fn sub(self, other: U64) -> U64 {
        self.sub(other)
    }
}

pub instance MulU64 Mul[U64, U64] {
    fn mul(self, other: U64) -> U64 {
        self.mul(other)
    }
}

pub instance DivU64 Div[U64, U64] {
    fn div(self, other: U64) -> U64 {
        self.div(other)
    }
}

pub instance PartialEqU64 PartialEq[U64] {
    fn eq(&self, other: &U64) -> Bool {
        self.eq(other)
    }
}

pub instance EqU64 Eq[U64]

pub instance PartialOrdU64 PartialOrd[U64] {
    fn partialCmp(&self, other: &U64) -> Option[Ordering] {
        if self.eq(other) {
            Some(Equal)
        } else {
            if self.lessThan(other) {
                Some(Less)
            } else {
                Some(Greater)
            }
        }
    }
}

pub instance OrdU64 Ord[U64] {
    fn cmp(&self, other: &U64) -> Ordering {
        if self.eq(other) {
            Equal
        } else {
            if self.lessThan(other) {
                Less
            } else {
                Greater
            }
        }
    }
}

pub instance CloneU64 Clone[U64] {
    fn clone(&self) -> U64 {
        self.clone()
    }
}

pub instance CopyU64 Copy[U64]

pub instance ShowU64 Show[U64] {
    fn show(&self) -> String {
        //showNum(self)
        showInt(self.toInt())
    }
}

pub instance NegU64 Neg[U64] {
    fn negative(self) -> U64 {
        self
    }
}

pub instance ModU64 Mod[U64] {
    fn mod(&self, other: &U64) -> U64 {
        self.mod(other)
    }
}

pub instance FromIntU64 From[Int, U64] {
    fn from(v: Int) -> U64 {
        v.toU64()
    }
}

pub instance IntoU64Int Into[U64, Int] {
    fn into(self) -> Int {
        self.toInt()
    }
}

}
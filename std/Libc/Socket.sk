module Libc.Socket {

import Array
import NativePtr

fn htons(value: U16) -> U16 {
    ((value & 255.toU16()) << 8.toU16()) | ((value >> 8.toU16()) & 255.toU16())
}

@derive(Discriminator, Clone, Copy, PartialEq, Eq)
pub enum Domain {
    AF_UNSPEC,
    AF_UNIX,
    AF_INET,

    pub fn code(&self) -> I32 {
        self.discriminator().toI32()
    }
}

@derive(Discriminator, Clone, Copy, PartialEq, Eq)
pub enum SockType {
    Unused,
    SOCK_STREAM,
    SOCK_DGRAM,
    SOCK_RAW,

    pub fn code(&self) -> I32 {
        self.discriminator().toI32()
    }
}

pub struct InAddr {
    pub s_addr: U32,
}

pub struct SockaddrIn {
    pub sin_len: U8,
    pub sin_family: U8,
    pub sin_port: U16,
    pub sin_addr: InAddr,
    pub sin_zero: Array[U8, 8],

    @unsafe
    pub fn new(family: Domain, port: U16, addr: U32) -> SockaddrIn {
        let ptr: *SockaddrIn = null();
        let sinPort = htons(port);
        let mut sockaddrIn = SockaddrIn(
            sin_len: sizeOf(ptr).toU8(),
            sin_family: family.code().toU8(),
            sin_port: sinPort,
            sin_addr: InAddr(s_addr: addr),
            sin_zero: Array.uninitialized(),
        );
        sockaddrIn.sin_zero.fill(0.toU8());
        sockaddrIn
    }

    pub fn len(&self) -> U32 {
        self.sin_len.toU32()
    }

    @unsafe
    pub fn asPtr(&self) -> *SockaddrIn {
        NativePtr.toPtr(self)
    }

    @unsafe
    pub fn addrPtr(&self) -> *InAddr {
        NativePtr.toPtr(&self.sin_addr)
    }
}

pub fn socket(domain: I32, ty: I32, protocol: I32) -> I32 = extern "C"
pub fn bind(sockfd: I32, addr: *SockaddrIn, addrlen: U32) -> I32 = extern "C"
pub fn listen(sockfd: I32, backlog: I32) -> I32 = extern "C"
pub fn accept(sockfd: I32, addr: *U8, addrlen: *U32) -> I32 = extern "C"
pub fn inet_pton(af: I32, src: *U8, dst: *InAddr) -> I32 = extern "C"
pub fn connect(sockfd: I32, addr: *SockaddrIn, addrlen: U32) -> I32 = extern "C"

}
